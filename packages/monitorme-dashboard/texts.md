**[FIXED]Module not found: Can't resolve 'react-datepicker'**
https://bobbyhadz.com/blog/module-not-found-cant-resolve-react-datepicker
Today I will show you how to fix the error "Module not found: Can't resolve 'react-datepicker'".


So, before attempting to import the `react-datepicker` package, ensure that it 
is installed first in order to address the "Module not found: Can't resolve 'react-datepicker'" 
error.

**How to Learn JavaScript Fast (Weeks not Months)**
*Take the ideas from the text above and write a unique introduction about how to learn javascript fast using a formal tone and fluid sentences.*
*Expand the text above*

Learning JavaScript quickly is made possible with the right strategy and dedication. 
Understanding the language's fundamentals, such as syntax and scripting capabilities, 
is essential for powerful and dynamic web development. Keeping up to date with the latest 
advancements and honing your skills can be done with online resources, like tutorials, 
blogs, and forums. Moreover, there are tools and frameworks, like Reactjs, Vuejs and Angularjs, 
that can accelerate the development process. 

In this article, I will discuss, which is in my opinion the right approach that would help you 
become a proficient JavaScript programmer in no time.

*The Importance of Practice*

Those wanting to rapidly improve their JavaScript skills must be willing to commit to regular 
practice. And I advice, especially at the beginning to code daily (5 days a week). 
Repetition and diligence are essential in mastering any skill, with programming being no exception. 
Through drills, challenges and projects, proficiency in coding can be achieved quickly 
and efficiently. Perseverance is key to success and the only way to truly master JavaScript.
If you follow this rule, your progression will be exponential.

*Paid and Free Tutorials to the Rescue*
It is possible to quickly gain knowledge of JavaScript through taking part in courses 
and tutorials. Many websites, like Udemy, offer courses that explore the different parts 
of JavaScript. YouTube is also a great platform to find free tutorials; just type 'JavaScript' 
into the search bar and you will be presented with a wide range of courses and tutorials. 
With the plethora of free JavaScript resources available today, it's easier than ever 
to learn this language quickly and effectively.

Pro Tip: When looking for YouTube channels that focus on JavaScript or other programming languages, 
a good rule of thumb is to check the number of views, and the ratio of views and likes, that the 
tutorial has. This will give you an idea of its quality. But, and if you want my opinion, the comments are
as important nowadays, so reading the comments should give you a more objective idea about the quality than
views and likes.

*How to Avoid/Escape Tutorial Hell?*

Experiencing the frustrations of tutorial hell first-hand while attempting to learn Vuejs was a 
difficult but important lesson for me. Initially, I was confident that the course I had taken had 
an experienced tutor and that Vuejs would be a piece of cake to learn. However, when I began 
building my own portfolio project, I quickly realised that I had no idea what I was doing. I had 
been jumping from one tutorial to the next, without really understanding what I was learning. 
As soon as I finished the tutorial, whatever knowledge I had gained was gone.

It took me some time to figure out the issue: my approach. To fix this, I decided to adapt my 
strategy and break up the courses and tutorials into smaller, more manageable parts. I also 
took regular breaks between lessons and researched concepts I wasn't familiar with. Additionally, 
I made sure to practice what I had learned and review the material. This method helped me better 
understand the material and apply it to real life scenarios.

*Going Free From Tutorial Hell*

Realizing that watching someone play football won't make you a good player, I had a similar 
epiphany that watching someone code won't make me a good developer. Tutorials had become 
my go-to for help and I was stuck in tutorial hell.

Then one day, I decided to take the plunge and code a Vuejs project from scratch, a simple 
dashboard application to manage job applications. It not only helped me build up my skills, 
but I actually ended up using it myself during my job search. This gave me the confidence to keep going, 
creating more projects and finding new concepts to borrow and implement. Eventually, I 
reached the point of being able to create projects without the help of tutorials.

*Learning How to Read Documentation*

If you want to become an expert in JavaScript, you should read the official documentation, 
particularly Mozilla JavaScript Reference from the MDN web docs. Additionally, gaining a 
deeper understanding of the language and doing coding exercises can help you to become proficient. 
Reading articles, books, as well as looking for tutorials and courses can also be very useful.
Furthermore, free resources such as DevDocs offer quick access to written documentation. 
Documentation is a key component of a programmer’s toolbox, as it can provide key information 
about the code, libraries, frameworks and tools being used. It can also help identify potential 
issues and offer best practices, tips, and other useful information for writing better code. 
Therefore, it is essential to remain up-to-date with the latest documentation in order to stay proficient.

To make the most of your programming journey, it's important to learn how to read the documentation. 
Most of the time, you can find the answers to your questions there. 
If the documentation is incomplete, your next step should be to read the source code.

*Keep Building Projects*

Creating projects is essential if you want to gain a comprehensive understanding of software. 
It allows you to explore the different processes that happen when you use a mouse or keyboard, 
and the more projects you build, the more knowledgeable you become. Plus, it's an incredibly 
rewarding experience that combines both technical and creative skills.

For those that need assistance, there are plenty of resources available to provide guidance. If you're 
just starting out, aim for one main project for your portfolio and four minor ones. The main project 
should be a fully-fledged application that incorporates various external services and APIs. 
This could include using an AI text generator API to create a draft email or a telemetry application 
to track user activity. Avoid simple CRUD applications as everyone is doing them.

Building projects (avoid CRUD at all costs!) is the key to mastering software, so go ahead 
and give it a go - you'll thank me when you get a job thanks to this approach. 

*Contributing to Open Source Software*

As a beginner developer, contributing to open-source projects is a great way to learn. 
There are lots of opportunities to do so on GitHub. Not only will you get to work on 
non-trivial individual projects, but you'll also gain essential skills like understanding, 
analyzing, and getting up to speed on large JavaScript codebases and helping to resolve issues. 
This is invaluable to employers and those who tell you otherwise are not being truthful.

To find projects to contribute to, search Google for `good first issues` and `good first issues javascript`.
Additionally, EddieHub is a great place to find welcoming developers who can help you get started with open source.

Not convinced yet? Here are more benefits of being an active open source contributor.
Contributing to open source can be a great way to learn in a practical way, gain an understanding of
different perspectives, build confidence, and expand your skills, tools, and technologies. 
Moreover, It can help create a good reputation, learn to understand feedback, network with new people 
and improve communication skills. 
Working on open source projects is also a great way to show off your skills and become an active 
member of the development community, which could help you expand your network and open up job
opportunities. Finally, it provides an opportunity to learn from others and build a personal brand.

For instance, I am currently contributing to `deno`, `rust-analyzer` and the `rust programming language`
projects, and I found it very rewarding both personnally and professionally.

So, start contributing and you'll soon be able to reap the rewards of your hard work.


*Last Words*

Learning JavaScript can be an excellent choice for those looking to get into coding. It's one 
of the most widely used programming languages, and understanding its best practices can help you make the most of it.

The best way to learn JavaScript is to practice coding and by building projects. Working through 
tutorials with a project can help you better grasp the language and its syntax. 
Additionally, contributing to open source code will help you develop your skills and stand out from the crowd.

Developing projects with JavaScript is a great way to not only understand how the language works but 
also how software works in general, and it can open the door to even greater creativity.

Wishing you the best of luck in your JavaScript journey.

**Why Use fs.createWriteStream() instead of Http Request?**

*Problem*

I don't understand why we need to do this:
```javascript
const response = response.data.pipe(fs.createWriteStream(destinationPath))
  .on("error", reject)
  .once("close", () => resolve(destinationPath))
```

Instead of just doing this and downloading the file in one go 

```javascript
const response = await axios({
  url,
  method: "GET",
});

const imageData = response.data;
```

*Solution*
Using a stream to download a file is more efficient than downloading it in one go because the file is 
downloaded in chunks, rather than all at once. This saves memory, as only the necessary data is being 
downloaded at any one time. Additionally, streams allow us to attach event handlers, so that we can 
handle errors, and know when the download is complete. This is not possible with the second example, 
as the entire file is downloaded in one go.

Piping the file in chunks will take each chunk and add it to a temporary file, which uses less memory 
than storing the whole file in memory and then writing it to disk. Imagine a file that is several gigabytes 
in size; this would require too much RAM and would eventually crash or slow down the system.

Here is the code that is used to send the data in chunks.

```javascript
await axios({
    url,
    method: 'GET',
    responseType: 'stream',
  })
```

The HTTP headers that are equivalent to the above code are:

```text
Content-Type: application/octet-stream
Accept: */*
User-Agent: axios/1.x
Range: bytes=0-
Connection: keep-alive
```

Here is an explanation of the headers. 
`Content-Type: application/octet-stream` - This header specifies the type of content that the request is 
expecting, which in this case is a stream of binary data.

`Accept: */*`: This header specifies that the request is accepting any type of content.

`User-Agent: axios/1.x` - This header identifies the application making the request.

`Range: bytes=0-` - This header specifies the range of bytes that the request is expecting. In this case, 
the request is expecting the entire file.

`Connection: keep-alive` - This header indicates that the connection should remain open after the request is 
complete. This allows subsequent requests to be made without having to re-establish the connection.

Here is the complete solution of how to download large files using Node.js:

```javascript
async function dl(url, dstPath) {
  const rsp = await axios({
    url,
    method: 'GET',
    responseType: 'stream',
  });

  return new Promise((resolve, reject) => {
    rsp.data
      .pipe(fs.createWriteStream(dstPath))
      .on('error', reject)
      .once('close', () => resolve(dstPath));
  });
}

const url =  "https://www.google.com/images/srpr/logo3w.png";
const dstPath = "example.png"; 

const res = await dl(url, dstPath);
```

**Transferred vs Resources Tabs in Chrome DevTools?**

The `Transferred` tab displays the amount of data that is transferred and compressed during page loading. 
Compression is a process where data is compressed to reduce its size before it is transmitted. 
By using compression, a webpage can be loaded faster as it requires less data to be transferred. 

The `Resources` tab displays the resources that are loaded, after being decompressed, with a page. 


Transferred  = Compressed data,   size   4.9KB 
Resources    = Uncompressed data, size  13.2KB


**How to Concatenate Two Slice in Golang**

Concatenating slices in Go is a useful way to combine two slices of the same type into one slice. 

This can be done using the `append()` function in golang. 

First, let's create two slices of integers.

```go
sliceOne := []int{1, 2, 3, 4}
sliceTwo := []int{5, 6, 7, 8}
```

Now, we can use the `append()` function to concatenate these two slices.

```go
sliceThree := append(sliceOne, sliceTwo...)
```

The three dots `(...)` after the second slice allow us to pass each element of the slice as an argument to 
the `append()` function.

The output of the above code will be:

```go
result := [1, 2, 3, 4, 5, 6, 7, 8]
```

*Why append(sliceOne, sliceTwo) Doesn't Work?*

Using the `append() function with just two slices will not work because it expects a variable number of arguments
with the type of the element of the slice and not the slice itself. 

Here is the signature of the function.
```go
func append(s []T, x ...T) []T
```

So the error is due to passing the wrong argument type to the append function.

**How to Concatenate Two Strings in Golang**
Go language is a statically typed, compiled language which follows the syntax similar to C language, and thus is 
very easy to learn (not so to master!), compared to Rust for instance. 

It is widely used for developing system applications, web development and cloud computing. Both kubernetes and
docker are built with Golang. 

One of the important operation while working with strings is to concatenate two strings.

In Go language, string is an immutable type, so whenever we are combining strings, it creates new string. There 
are three ways to concatenate strings in Go language, they are:

*Using '+' Operator*

The `+` operator is used to combine two strings and creates a new string. A new allocation is needed then.

Here is an example below that shows how to concatenate two strings. 

```go
package main

import "fmt"

func main() {
    str1 := "Welcome"
    str2 := "to"
    str3 := "Utopia"
  
    str4 := str1 + " " + str2 + " " + str3
    fmt.Println(str4)
}
```

Here is the output of the program.
```go
Welcome to Utopia 
```

*Using String Append '+=' Operator*

The string append operator `+=` adds the second string to the end of the first string and returns the updated 
string.

Now, here is an example of how to concatenate two strings.

```go
package main

import "fmt"

func main() {
    str1 := "Welcome"
    str2 := "to"
    str3 := "Utopia"
  
    str1 += " " + str2 + " " + str3
    fmt.Println(str1)
}
```

Here is the output to the console of the program above.

```text
Welcome to Utopia 
```

*Using Sprintf()*

The `Sprintf()` is a formatting function which can be used to concatenate strings.

Here is an example of how it is done. 

```go
package main

import "fmt"

func main() {
  str1 := "Welcome"
  str2 := "to"
  str3 := "Utopia"
  
  str4 := fmt.Sprintf("%s %s %s", str1, str2, str3)
  fmt.Println(str4)
}
```

Here is the output.

```text
Welcome to Utopia
```

**How to Check if a String is Empty in Golang**

Go language provides two ways to check for an empty string. We can either compare with an empty string or 
check the length of the string. Both approaches are used in official Golang’s libraries. 
Depending on our coding style one of the following approaches can be used. 

*Comparing with an Empty String*

One way to check for an empty string is to compare it with an empty string. The method is to use the `==` operator. 

Here is the example program.

```go
package main

import "fmt"

func main() {
    str1 := ""
    str2 := "Hello World!"

    if str1 == "" {
        fmt.Println("String 1 is empty")
    }

    if str2 == "" {
        fmt.Println("String 2 is empty")
    }
}
```

Here is the output of the example program. 
```text
String 1 is empty
```


*Checking the Length of the String*

We can also check if a string is empty by checking its length. This can be done using the `len()` 
built-in golang function. 


Here is an example program of how to check if a string is empty.

```go
package main

import "fmt"

func main() {
    str1 := ""
    str2 := "Hello World!"

    if len(str1) == 0 {
        fmt.Println("String 1 is empty")
    }

    if len(str2) == 0 {
        fmt.Println("String 2 is empty")
    }
}
```

Here is the output of the program above.

```text
String 1 is empty
```

**How to Sleep for 1 Second in Golang**

You can pause the execution of a program using the `time.Sleep()` function in Golang.
The amount of time can be in nanoseconds, milliseconds, or seconds. 

So, how to pause for 1 second?

First, we need to import the time package in our program:
```go
package main
import (
  "time"
  "fmt"
)
```

Next, we can use the `time.Sleep()` function that takes a single parameter, which is the amount of time to pause 
the program for, for our case 1 second.

```go
func main() {
  fmt.Println("Sleeping...")
  time.Sleep(1 * time.Second)
  fmt.Println("ok")
}
```

When this code is executed, the program will pause for 1 second, and then print the message "ok" to the screen.

**For Each Loops in Golang**

In Golang there are no built-in foreach loops, however it is possible to replicate the behavior of a foreach 
loop using a `for` loop. 
For loops in Golang can be used with a `range` clause to loop through all elements of an array, slice, string or map. 
For each element, it assigns iteration values to corresponding iteration variables if present, and then runs the block.

In the following, I will show you an example to better explain how it works. 

We will loop through a slice of integers and print the value of each of its elements.
```go
// Create a slice of integers
intSlice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}

// Loop through the slice
for i, v := range intSlice {
	fmt.Printf("Index: %v, Value: %v\n", i, v)
}
```
Here is the output of the above code snippet in the following. 

```text
Index: 0, Value: 1
Index: 1, Value: 2
Index: 2, Value: 3
Index: 3, Value: 4
Index: 4, Value: 5
Index: 5, Value: 6
Index: 6, Value: 7
Index: 7, Value: 8
Index: 8, Value: 9
```

As you can clearly see, the `for` loop looped through the slice and assigned the index and value of each element 
to the variables `i` and `v` respectively. It then printed for each element its index and value.


**Explaining the if Flags in Shell**
For the hundredth time, I encountered the following Bash shell code snippet, and, as usual, I wondered what the `-z "$GPG_KEY"` meant. 

```shell
if [[ -z "$GPG_KEY" ]]; then
	GPG_KEY=/secrets/key.gpg
fi
```
So, instead of simply searching for an answer on Google and forgetting about it in the next minute, I decided to 
write a quick tutorial to cement my knowledge in this topic.


*What is the If Statement in Shell?*

The `if` statement is a powerful tool in Bash shell scripting that allows you to execute commands based on 
certain conditions. One of the most useful features of if statements is the ability to use flags. 
Flags are special operators that allow you to test certain conditions in order to decide whether or not 
the condition is true.


*Using Flags with If Statements in Shell*

In the above code snippet, an if statement is used to check if the value of the environmental variable `GPG_KEY` is 
empty or not. 

The `-z` flag is used to test if the value is empty or not. If the value is empty, then the value of the 
environmental variable GPG_KEY is set to `/secrets/key.gpg`.

*Other Possible Flags in If Statements*


`-e` : It will test if a given file or directory exists. So, if you wanted to test if a file named `file.txt` exists, 
you could use the following code:

```shell
if [ -e "file.txt" ]; then
    echo "The file exists!"
fi
```

`-f` : It will test if a given file exists and is a regular file. This is useful if you want to make sure that the 
given path is not a directory.

`-s` : This will test if a given file exists and is not empty.

`-gt` : This will test if the first argument is greater than the second argument. This can be used with numbers, 
strings, and other variables.

`-lt` : Similar to `-gt`, it will test if the first argument is less than the second argument. 

`-eq` : It will test if the two arguments are equal. This can be used with numbers, strings, and other variables.

There are even more flags that you could make use of with the if statement, such as `-le` (less than or equal to), 
`-ge` (greater than or equal to), `-ne` (not equal to), and `-o` (or). These flags are self-explanatory, so no 
further text is needed to avoid making this article too long.

**JavaScript Build Tools Trends in 2023**

Last year (2022) has seen the rise of many new JavaScript build tools, as well as the continued growth of existing ones. 

Vite is one of the most popular frontend tools and is being used for a variety of projects, from SvelteKit and Storybook 
to Vitest and Create-React-App. Monorepo tools like Nx and Turborepo have also seen an increase in popularity and are 
being used to optimize builds.

Babel remains popular, but new tools like swc and esbuild have been adopted by many projects and meta-frameworks. These 
tools allow for faster builds and transpilations, with swc offering a plugin system for more modularity. Vercel’s 
Turbopack is an alpha-stage bundler built in Rust, and Rome’s toolchain released its first stable version with a linter 
and formatter.

Rust-based frontend tools are also making their presence known this year. Lightning CSS (formerly Parcel CSS) is a 
faster CSS toolchain, Speedy TypeScript type checker is a faster alternative to tsc, and mdxjs-rs is a faster 
MDX implementation.

Overall, there is great potential for JavaScript build tools this year (2023), as new and existing tools continue to 
improve performance and quality. With the rise of monorepo tools and Rust-based frontend tools, developers have more 
options than ever before to create efficient and high-quality builds.

**A Very Fast CSS Build Tool**

Today, I've found out about `Lightning CSS` which is written in `Rust`. 

Lightning CSS is a revolutionary new CSS minification tool that is over 100x faster than its JavaScript-based 
counterparts. 

From the official website: "It can minify over 2.7 million lines of code per second on a single 
thread, making it an ideal choice for large-scale projects."

*Written with Performance in Mind*

Lightning CSS has been written in Rust, a native systems programming language, with performance at the forefront 
of its design. It makes efficient use of memory and limits AST passes to ensure the highest level of performance.

*Supports Modern CSS Features*

Lightning CSS also supports modern and future CSS features, such as CSS nesting, custom media queries, high gamut 
color spaces, logical properties, and new selector features. These features are automatically converted to more 
compatible syntax based on your browser targets. Vendor prefixes are also automatically added, which keeps the 
source code clean and free of repetition.

*Produces Smaller CSS Size*

In addition to its impressive speed, Lightning CSS produces smaller output code, so your website loads faster. 
It does this by combining longhand properties into shorthands, removing unnecessary vendor prefixes, merging 
compatible adjacent rules, removing unnecessary default values, reducing calc() expressions, shortening colors, 
and minifying gradients.

*Last Words*

Overall, Lightning CSS is a great tool for developers who need to quickly minify large amounts of code. It is 
fast, efficient, and produces smaller output code, which all leads to faster loading times. With its wide range 
of features, it's no wonder why Lightning CSS is quickly becoming the go-to choice for developers.

Check it out and let me know what you think.


**Ways to Check if a Key Exists in a Golang Map**

In today's article, I will explain how you can check if a key exists in a map using three different method.



A Golang map is a collection of key-value pairs and is equivalent or similar to a dictionary in Python or an Object in 
JavaScript. It is an unordered collection of elements of one or more types. 

Let's explore the three ways with which we can check if a map contains a key.

The first method uses the index notation, 
The second method uses an if statement,
The third method uses an if statement with a blank identifier.

*Using Map Index Notation*

The simplest way to check if a map contains a key is to use Go map index notation. With this method, you can access 
the value associated with the key and assign it to a variable. If the key exists, the returned value will be 
assigned to the variable. Otherwise, the zero value of the value type will be returned.

A example is worth a thousand words, so let's get at it.

```go
myColors := map[string]string{
  "red": "#ff0000",
  "green": "#00ff00",
  "blue": "#0000ff",
}
```

Now, to check if the map contains the key `red`, we can use the following code:
```go
val, ok := myColors["red"]
```

If the key exists, the value associated with the key will be assigned to the `val` variable and the boolean 
value `true` will be assigned to the `ok` variable. Otherwise, the val variable will be assigned the zero 
value of type string and the ok variable will be assigned `false`.

*Using an If Statement*

The secon method uses an if statement that checks if a map contains a key. This method is similar to the one 
mentioned above, but instead of assigning the value associated with the key to a variable, you can directly 
use the boolean value returned by the if statement.

Here is how you can use it to check if the map contains the key `blue`.

```go
if _, ok := myColors["blue"]; ok {
  fmt.Println("Blue exists in the map")
}
```

If the key exists, the boolean value `true` will be returned and the statement inside the if block will be 
executed. Otherwise, the boolean value `false` will be returned.

*Using an If Statement and a Blank Identifier*

The last method to check if a map contains a key is to use an if statement and a blank identifier. With this method, 
you can directly use the boolean value returned by the if statement without assigning the value associated with the 
key to a variable.

In order to check if the map contains the key `green`, we can use the following code:

```go
if _, ok := myColors["green"]; ok {
  fmt.Println("Green exists in the map")
}
```

If the key exists, the boolean value `true` will be returned and the statement inside the if block will be 
executed and `false` otherwise. 


**How to Make an HTTP POST Request in Golang**

Go provides an easy way to make HTTP POST requests using the `net/http` package. In most cases the data that 
needs to be sent is in the form of JSON and the response is also returned in JSON format. 

In the following, I will explain how to make an HTTP POST request with JSON data using a Golang code example.

The `net/http` package provides methods for creating and sending HTTP requests. The first step is to create an 
HTTP request object with the `http.NewRequest()` function. This function takes three arguments: the request type 
(`POST` in our case), the URL and the request data.

The request data needs to be in the form of a `bytes.Buffer` object, which can be created using the `bytes.NewBuffer()`
function. The data needs to be in the form of a valid JSON string, so it can be converted to a `bytes.Buffer` object 
using the `json.Marshal()` function.

The second step is to set the content type of the request to `application/json`. This can be done by setting 
the `Content-Type` header to that value.

The third step is to create a client and make the request using the `client.Do()` method.

Here is a complete example of how it is done. 

```go
package main

import (
  "bytes"
  "encoding/json"
  "fmt"
  "net/http"
)

func main() {
  // Create request data
  data := map[string]interface{}{
    "name": "Martin James",
    "age":  40,
  }
  jsonData, _ := json.Marshal(data)

  // Create HTTP request
  req, _ := http.NewRequest("POST", "https://reqres.in/api/users", bytes.NewBuffer(jsonData))
  req.Header.Set("Content-Type", "application/json")

  // Create HTTP client
  client := &http.Client{}
  resp, err := client.Do(req)
  if err != nil {
    fmt.Println(err)
    return
  }
  defer resp.Body.Close()

  // Print response
  fmt.Println(resp.StatusCode)
}
```
The output of the above code will be:
```text
201
```


**Using Environment Variables with Nodejs**

In today's article, I will explain how you can use env variables through the `.env` file in Node.js.

Environment variables are a great way to store information that you don't want to hard-code into your 
Node.js application, like passwords, API keys, or other sensitive information. 
Let's look at how to use environment variables in Node.js.

First, let’s create a `.env` file in the root of your project. This file will contain all of your 
environment variables. 

Let's look at an example to understand better how it works.  

```text
API_KEY=SOME_SECRET_KEY
PORT=3000
```

Now, the next step is to install the `dotenv` package. 

```shell
npm install dotenv
```

Now, in our Node.js application, we could simply import the `dotenv` package and use it to load the 
environment variables the newly created `.env` file. 

Here is a code snippet to do so.

```javascript
import * as dotenv from 'dotenv'
dotenv.config()
```

Now that the environment variables are loaded from the file, we can access them using the 
the usual `process.env` object. 

Here is how it is done. 

```javascript
const apiKey = process.env.API_KEY;
const port = process.env.PORT;
```

Now, if you want to deploy your application to a production environment, you will need to set your 
environment variables in the server itself. 
Deployment environments such as Heroku and AWS let you do this with ease.


*What is a .env File?*
A `.env` file is a file that contains environment variables that can be used in a Node.js application.

*How do I Install the dotenv Package?*
You can install the `dotenv` package by running the command:
```shell
npm install dotenv
```

*How do I access my environment variables with Nodejs?*
In Node.js, you can access your environment variables by using the `process.env` object.

*How do I Deploy my Application to a Production Environment?*
You can deploy your application to a production environment by setting your environment variables 
in the hosting environment. This can be done using tools like Heroku or AWS.

*Can I Use Environment Variables with Node.js?*
Yes, you can use environment variables with Node.js by creating a `.env` file and using the 
`dotenv` package.



**Go**

```bash
set -e

family=Hasklig
roman_weights=(Black Bold ExtraLight Light Medium Regular Semibold)
italic_weights=(BlackIt BoldIt ExtraLightIt LightIt MediumIt It SemiboldIt)

DIR="( cd "$( dirname "${BASH_SOURCE[0]}" )" > /dev/null && pwd )"
```

**What is BASH_SOURCE[0]?**

In this article, we will try to understand what is the bash variable `BASH_SOURCE`.

*What is BASH_SOURCE?*

`BASH_SOURCE` is an array variable whose members are the source filenames where the corresponding shell function 
names in the `FUNCNAME` array variable are defined. 
It contains the (potentially relative) path of the containing script in all invocation scenarios, notably also 
when the script is sourced. When the script is sourced, `$0` contains `"-bash"`, while `${BASH_SOURCE[0]}` 
contains the path of the script.

Important Note: In Bash, the `FUNCNAME` array variable (an array of strings) contains the names of all 
shell functions currently in the execution stack. 

*What is BASH_SOURCE[0]?*

`BASH_SOURCE[0]` is the first element of the `BASH_SOURCE` array, which contains the full pathname of the script 
being executed. This can be used to determine the directory of the script and access other files in the same directory.

*Example of Usage*

One example of using `BASH_SOURCE` is to determine the directory of the script and access other files in the same 
directory. 

Here is an example of how it can be used.

```bash
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
```

The bash script code above is used to determine the current working directory of the script. The 
variable `BASH_SOURCE[0]` is used to access the script's file name, and the `pwd` command is used to get 
the path of the current working directory. The output of this code is a string containing the 
absolute path to the directory containing the script which is then assigned to `DIR`.


**What is the Difference between cwd and pwd?**

Today, I wondered about what is the difference between two shell commands, i.e. `pwd` and `cwd`. 

*Similarities*

First, there are similar in the sense that both display the current working directory. 

The `pwd` command stands for `Print Working Directory`.
On the other hand, `cwd` stands for `Current Working Directory`. 

*Differences*

The `pwd` command will always print out the absolute path of the current working directory, while 
`cwd` may print out the relative path of the current working directory.

As an example if your current directory is `/home/user/Documents`, then using the command:

```bash
pwd 

/home/user/Documents
```

Now, if you were to use the command, it may print the following:

```
cwd 

./Documents
```

https://stackoverflow.com/questions/30991319/whats-the-difference-between-process-cwd-vs-process-env-pwd


**How to Disable Back Button in HTML Page?**

Most answers do not work as they are outdated.


So what is the solution?  A javascript function can be written to prevent users from navigating back to 
the previous page. 

Popular methods of doing this include adding code to the previous page to force the browser to go forwards, 
or creating a custom function. 


The idea is that the JavaScript code will prevent users from going to the last page no matter how many times
they press the back button.


*Working Method*

Beware that most answers that you will find online either don't work or are outdated
As of Chrome 79 and beyond, the following method works. 

```html
<script> 
  history.pushState(null, null, location.href);
  history.back();
  history.forward();
  window.onpopstate = function () { history.go(1); };
</script>
```
The above script is a custom function which can be used to prevent users from navigating back to the 
previous page. It uses the history object to push the current page to the top of the browser's history 
stack, so when the user clicks the back button, the browser will take them to the same page. 
The `history.back()` and `history.forward()` functions are used to ensure that the user stays on the same 
page regardless of how many times the back button is clicked. 
Eventually, the `window.onpopstate` event is used to capture the user's attempt to go back and force them 
forwards again.

Now, you might be wondering what the `history.go(1)` do? Keep reading.

The `history.go(1)` function in JavaScript allows the browser to move one entry forward in the browsing 
history. If a user is on page A and clicks the back button, `history.go(1)` will take them back to 
page A rather than the page they were on previously. The value of 1 signifies that when the user 
clicks the back button, it goes one step back in the history. To stay on the same page, we must go one 
step forward, and thus `history.go(1)` is used.

**How to Create an Empty Commit in Git using the Flag --allow-empty**

Git is a powerful version control system that enables developers to collaborate more effectively. It offers 
the ability to create empty commits, which can be used to mark a specific point in the commit history or 
to track changes without modifying any files.

An empty commit is a commit that has no changes to any files. This means that the commit message and author 
information are the only data recorded in the commit. You can create an empty commit using the command: 

```bash
git commit --allow-empty -m "Your commit message"
```

This command will create an empty commit with the message you provide. You can also add an author name and 
email address to the commit by adding the following flags to the command: 

```bash
git commit --allow-empty -m "Your commit message" --author="Author Name <author@example.com>"
```

Note: The `--allow-empty` flag is necessary for creating an empty commit. Without this flag, the commit will 
fail because it contains no changes.

*Why Empty Commits You Would Ask?*

Empty commits can be very useful when you want to mark a point in the commit history or if you need to keep track 
of changes that don't involve modifying any files. While they are not always necessary, they can be helpful in 
very specific situations.



**Vue Methods Tutorial**

Vue.js is a popular JavaScript framework used to create web applications. One of the 
core features of Vue.js is its powerful methods. Vue methods are functions that can 
be called directly on a Vue instance to interact with the data and other components of 
the application. 


I will share with you everything I know about Vue methods and it should be enough to get
a complete overview of this feature of the Vue framework.

*Declaring Methods in a Vue Instance*

An example of a Vue method would be a method that calculates the total cost of a shopping cart. 
The method would take in an array of items in the cart and use a loop to add up the individual 
costs.

```javascript
function calculateTotal(cartItems) {
  let total = 0;
  cartItems.forEach(item => {
    total += item.price;
  });
  return total;
}

// Usage
const cartItems = [{ name: 'Shoes', price: 50 }, { name: 'Shirt', price: 30 }];
const total = calculateTotal(cartItems);
console.log(total); // 80
```

Here is how it is used in a Vue template. 

```html
<template>
  <div>
    <h1>Total Price: {{totalPrice}}</h1>
    <ul>
      <li v-for="item in cartItems">{{item.name}} - {{item.price}}</li>
    </ul>
  </div>
</template>

<script>
export default {
  data() {
    return {
      totalPrice: 0,
      cartItems: []
    }
  },
  methods: {
    calculateTotal() {
      let total = 0;
      this.cartItems.forEach(item => {
        total += item.price;
      });
      this.totalPrice = total;
    }
  }
}
</script>
```


*How to Create a Method in Vue*

In order to create a method in Vue you need to first create a Vue instance, then you can create 
the method within the instance.

Here is a minimal example of how a method `greet()` can be added and used in a vue instance.

```javascript
// Create a new Vue instance
const app = Vue.createApp({
  data() {
    return {
      username: "", 
    }
  },
  methods: {
    greet() {
      alert(`Hello ${this.username}!`);
    }
  },
  template: `
  <div>
    <p>Username: {{username}}</p>
      <input v-model="username" />
      <button @click="greet">Greet</button>
    </div>
    `,
});

app.mount("#app");
```

*When to Use Methods in Vue*

Methods are ideal for performing data manipulation tasks in Vue. For instance, you can use 
methods to filter and sort data, manipulate the DOM, and perform calculations. Methods 
are also commonly used to respond to user input, such as submitting a form or clicking a 
button. In addition, Vue methods can be used to control the flow of an application, 
such as routing or authentication.

*When Not to Use Methods in Vue*

When not to use methods in Vue is when you want to perform a task that is better suited to a 
lifecycle hook or computed property. If you want to perform a task for which the data of the 
application changes, a computed property is the better choice. Similarly, if you want to perform 
a task when a component is created, the ideal solution would be to use the right lifecycle hook.

*Can Methods be Async?*

Yes, methods can be asynchronous in Vue.js. Here is in the following how you can create an 
asynchronous method to fetch data from an API. Here is how to use an async method in 
a vue application. 

```javascript
// Create a new Vue instance
const app = Vue.createApp({
  data: {
    story: null 
  },
  methods: {
    // Create the asynchronous method
    async getData() {
      const response = await fetch('https://someapiurl.com/data');
      const data = await response.json();
      this.story = data[0].story;
    }
  },
  template: `
  <div>
    <button @click="getData()">Get Data</button>
    <div v-if="data">
      <p>Short story: {{ story }}</p>
    </div>
  </div>
  `
});

app.mount("#app");
```

*Reactivity in Vue Methods*

In Vue, reactivity is the ability to detect changes of data and update the UI accordingly. 
And this can be applied to vue methods as well that contain changed data. Vue makes it easy 
to create reactive methods by using the `this` keyword to access the data. 

Here is, below, an example app that makes use of a reactive method that updates a message 
when the value changes.

```javascript
// Create a new Vue instance
const app = new Vue({
  el: '#app',
  data: {
    message: 'Hello World!',
    value: 0
  },
  methods: {
    // Create the reactive method
    updateMessage() {
      this.message = `Value is now ${this.value}`;
    }
  },
  template: `
  <div>
    <p>Message: {{ message }}</p>
    <input type="number" v-model="value" @input="updateMessage()" />
  </div>
  `
});
```

The method `updateMessage()` gets invoked when the value of message changes.

*Last Words*

Vue methods are powerful tools for building interactive interactive web applications. They can be used to 
perform data manipulation tasks, respond to user input, and control the flow of an application. 
Vue methods can also be made reactive to detect when the data of the application changes and update 
the UI accordingly.

**Go to Previous Page Without Using the Back Button** 

If you’re looking for a way to navigate back to a previous page without using the browser’s back 
button, then keep reading! 

Good news is that it will only require a single line of code to implement a back button behavior 
using JavaScript. 

*Using history.back()*

First, let’s take a look at the `history.back()` method. This method allows you to go back to the previous 
page in the history list. All you need to do is add the following code to your script: 

```javascript
history.back();
```

*Using history.go()*

The `history.go(-1)` method is another way of going back to the previous page. This method works by specifying 
a number, indicating how many pages back you wish to go. 

Here is the code that mimics pressing the back button once:  

```javascript
history.go(-1);
```

*Last Words*
These methods are especially useful for customizing the navigation of your website. One of the potential
usages of this code is for implementing a button with a `click` event listener which would send you to 
the previous page. In other words, you could implement a back button of our own.

**Three Ways to Go a Web Page using JavaScript**

JavaScript is a popular programming language in 2023. It allows developers to add 
dynamic content, such as visuals, sounds, and animations, to make their websites 
more appealing. 
JavaScript can also be used as back-end language but that's not the subject
of this article. 

We'll focus in this article on how to navigate to a page using JavaScript in the browser.

*Using location.href*

One way to navigate to a web page using JavaScript is by modifying the value of the 
`location.href` property. This property sets the URL of the current window. 

Here is the syntax with an example of changing the current page to Google.

```javascript
location.href="http://www.google.com";
```

*Using location.replace()*

Another way to navigate to a web page using JavaScript is with the `location.replace()` method. 
This method replaces the current document with a new one, without adding it to the history 
stack. Here is the code that will navigate to Google's homepage. 

```javascript
location.replace("http://www.google.com");
```

*Using location.assign()*

Last but not least, the `location.assign()` method can be used to navigate to a web page 
using JavaScript. This method loads a new document and adds it to the history stack. 

Below is the code snippet that will go to the most popular search engine as of 2023. 

```javascript
location.assign("http://www.google.com");
```

*What is the Main Difference between `location` `href`, `assign` and `assign`?*

The main difference between the three methods is how they affect the history stack. 
The `location.href` property does not affect the history stack at all. 
On the other hand , the `location.replace()` method replaces the current document 
with a new one, without adding it to the history stack. 
Lastly, the `location.assign()` method loads a new document and adds it to the history stack.

*Last Words*

Thre are three main ways to navigate to a web page using JavaScript, which use `location.href`, `location.replace()`, and `location.assign()` methods, respectively. 
Each of these methods affects the history stack differently, allowing you to choose the best option 
for their needs.


**What is Dollar $ Ampersand & in Bash**
Todo! https://askubuntu.com/questions/833833/what-does-command-do
Bash is a type of Unix shell and command language used for various operations on a computer system. The dollar sign is a special character in bash that is used to represent variables and other special operations. This article will explain the purpose of the dollar sign in bash, provide examples of how it is used, and discuss some of the best practices for using it.

What is the Dollar Sign Used For in Bash?

The dollar sign is used in bash to denote a variable, either a user-defined or a system-defined one. This means that the dollar sign can be used to reference a value stored in a particular variable, such as the current working directory, or to assign a value to a particular variable, such as the name of a file.

The dollar sign can also be used for various special operations in bash, such as using parentheses to group commands together, or using curly braces to expand the contents of a variable. Additionally, the dollar sign can be used to access command line arguments, as well as to access environment variables, such as the current user’s home directory.

Examples of Using the Dollar Sign in Bash

To better understand the role of the dollar sign in bash, consider the following examples.

Using the Dollar Sign for Variables

The dollar sign is used to reference variables in bash. For example, to reference the user’s current working directory, the dollar sign is used in combination with the “PWD” variable, like this:

echo "The current working directory is: $PWD"

This command will output the current working directory:

The current working directory is: /home/username

Using the Dollar Sign for Special Operations

The dollar sign can also be used in bash for special operations. For example, the dollar sign can be used in combination with parentheses to group commands together, like this:

$(echo "This is the first line."; echo "This is the second line.")

This command will output the following:

This is the first line.
This is the second line.

Additionally, the dollar sign can be used in combination with curly braces to expand the contents of a variable, like this:

echo "The path is ${PATH}"

This command will output the user’s current PATH variable:

The path is /usr/local/bin:/usr/bin:/bin

Best Practices for Using the Dollar Sign in Bash

When using the dollar sign in bash, it is important to remember that it is case-sensitive. This means that the dollar sign must be used in the same case as the variable it is referencing. For example, if the variable is “PWD”, the dollar sign must be used in combination with the lowercase “p” to reference it, like this:

$PWD

Additionally, it is important to remember that the dollar sign should not be used in combination with quotation marks, as this can result in unexpected behavior.

Finally, it is important to remember that the dollar sign can be used to reference variables and special operations in bash, but it cannot be used to execute commands. To execute commands in bash, the dollar sign should not be used.

Conclusion

The dollar sign is an important part of the bash scripting language. It is used to reference variables and for various special operations, such as grouping commands together or expanding the contents of a variable. This article has explained the purpose of the dollar sign in bash, provided examples of how it is used, and discussed some of the best practices for using it.




**How to Toggle Case Between Upper and Lowercase in VIM?**

Today I've learnt how to toggle between lowercase and uppercase in vim and the shortcuts that 
would help you save time and effort.

*What is Case Toggling in VIM?*
Using VIM to toggle the case of text is a great way to quickly and easily modify text. 
The toggle case command is used to change the case of selected text from lowercase to uppercase or uppercase to lowercase. 
This command can be used to quickly and easily modify text without having to retype the entire text.

*Different Ways to Toggle Cases*

To toggle the case of selected text in vIM, you can use the command `gU` for uppercase and `gu` for lowercase. 
For example, if you wanted to make the following transformation.

`gUU`: `This is a Sample Text` to `THIS IS A SAMPLE TEXT`

`guu`: `THIS IS A SAMPLE TEXT` to `this is a sample text` 

Those two shortcuts would transform the whole line.


*Toggle Case VIM Shortcuts*

Now, here are all the useful commands that you would need to toggle cases in VIM. 

`~` Toggle the case of the character under the cursor or all visually-selected characters

`gU` Toggle to uppercase the visually-selected text.

`gUU` Switch the line under the cursor to uppercase.

`gUiw` Switch the word under the cursor to uppercase.

`u` Switch to lowercase the visually-selected text.

`gu` Switch to lowercase the visually-selected text.

`guu` Switch the line under the cursor to lowercase.

`4~` Toggle case of the next four characters. The 4 is variable, you can use any number based on your needs.

`g~4w` Toggle case of the next three words. The 4 is variable, you can use any number based on your needs.

`g~iw` Toggle case of the word under the cursor.

`g~$` Toggle case of all characters starting from the cursor up to the end of the line.

`g~~` Toggle case of the current line under the cursor.


**Rust vs Go**

https://www.simplilearn.com/tutorials/golang-tutorial/guide-to-golang-vs-rust

**Must Have Soft Skills for Software Developers**
https://pointjupiter.com/soft-skills-software-developer-need-ultimate-guide/
https://www.trio.dev/blog/software-engineer-soft-skills

**Borrow Trait in Rust**

Borrowing data is a common practice in Rust. Different representations of a type can be provided 
for different use cases. For example, `Box<T>` or `Rc<T>` can be used for storing and managing values. 
Additionally, some types such as String provide optional features that require additional data. 

By implementing the `Borrow<T>` trait, types express that they can be borrowed as type `T` and provide 
a reference to the underlying data in the trait’s borrow method. Types may borrow as several different 
types and can additionally implement `BorrowMut<T>` to enable mutable borrowing. 

When providing implementations for additional traits, they should behave identically to those of the 
underlying type, so that `x.borrow() == y.borrow()` produces the same result as `x == y`. 
In this case, it is better to use `AsRef<T>` as more types can safely implement it.

Here is the trait definition below

```rust
pub trait Borrow<Borrowed> where 
    Borrowed: ?Sized {
    fn borrow(&self) -> &Borrowed;
}
```

*How Hashing Works in Rust*

Here is how hashing works in rust. We need to understand it in order to understand the importance of having the 
same implementation for both `K` and `Q` in the context of the `Borrow` trait. 

The hash trait, `Hash` implementation needs to be the same for K and Q because the hash map relies on the 
hash value of the key to determine the correct hash bucket. If the hash values of `K` and `Q` are different, 
the map will be unable to correctly determine the bucket and retrieve the value correctly. 
Additionally, the map also uses the `Eq` trait to check if the key is already present in the bucket. 
Therefore, both K and Q must have equivalent implementations of Hash and Eq in order for the hash map to 
function correctly.

*Example of Rust Documentation (CaseInsensitive Type)*

`CaseInsensitiveString` is a type that wraps a string and compares ASCII letters ignoring their case. 
It can be used as a key in a hash map, provided that it has implementations of the `Hash` and `Eq` traits 
that produce identical results to those of the underlying str.

However, implementing `Borrow<str>` is not possible, as the Hash implementation of CaseInsensitiveString must ignore ASCII case, which would produce a different hash than the underlying str.

For instance, the hash value of the string `"MYKEY"` would be different from the hash value of `CaseInsensitiveString("MYKEY")` due to the fact that the hash trait of the `String` takes into account the case, whereas the hash implementation of `CaseInsensitiveString` ignores it. 

```
For "MYKEY"                         hashFunction(  "MYKEY"  ) hash -> 206 
For CaseInsensitiveString("MYKEY")  hashFunctihn(  "mykey"  ) hash -> 123

hashFunction( "mykey" ) !== hashFunction( "MYKEY" )
```

Please ignore the fact that I didn't differenciate between `String` and `str`. That doesn't play a role in what
I am trying to get to.

If `CaseInsensitiveString` wants to allow others access to the underlying `str`, it can do so via `AsRef<str>` 
which does not require any additional requirements.

Here is the source code for CaseInsensitiveString:

```rust
pub struct CaseInsensitiveString(String);

impl PartialEq for CaseInsensitiveString {
    fn eq(&self, other: &Self) -> bool {
        self.0.eq_ignore_ascii_case(&other.0)
    }
}

impl Eq for CaseInsensitiveString { }

impl Hash for CaseInsensitiveString {
    fn hash<H: Hasher>(&self, state: &mut H) {
        for c in self.0.as_bytes() {
            c.to_ascii_lowercase().hash(state)
        }
    }
}
```

If `CaseInsensitiveString` wants to allow others access to the underlying `str`, it can do so via `AsRef<str>` 
which does not require any additional requirements.



**Cow Rust Tutorial**
https://dev.to/kgrech/6-things-you-can-do-with-the-cow-in-rust-4l55
https://dhghomon.github.io/easy_rust/Chapter_42.html
https://deterministic.space/secret-life-of-cows.html


**How to Get the Length of an Array in Python**
https://www.askpython.com/python/array/array-length-in-python
**Ways to Trim a String in Python**
https://www.askpython.com/python/string/trim-a-string-in-python


**other articles**
www.golangdocs.com
golang substring
golangdocs.com/substring-in-golang
golang ternary
golangdocs.com/ternary-operator-in-golang
golang sleep
golangdocs.com/sleep-function-in-golang
go ternary
golangdocs.com/ternary-operator-in-golang
golang line
golangdocs.com/golang-read-file-line-by-line
go substring
golangdocs.com/substring-in-golang
golang global var
olangdocs.com/golang-global-variables
golang list
golangdocs.com/list-container-in-go
golang global variables
golangdocs.com/golang-global-variables
golang read file line by line
golangdocs.com/golang-read-file-line-by-line

**How to Remove a Property from an Object in JavaScript?**

If you're here, you're probably looking for a way to clear an object property in JavaScript. 
In this article, we'll discuss how to use the `delete` operator to clear an object property. 
So let's get started!

To clear an object property in JavaScript, you can use the `delete` operator. 

The syntax for the `delete` operator is:

```javascript
delete objectName.propertyName;
```

Here is an example of its usage.

```javascript
let obj = {
    a: 100,
    b: false, 
    c: "three"
};

delete obj.a;  // delete property 'a'

console.log(obj); // { b: false, c: 'three' }
```

The code above uses the `delete` operator to remove the property named 'a' from the object called
'obj'. After the `delete` operator has been used, the object will no longer contain the property. 
As a result, the `console.log` statement will output the object with only the 'b' and 'c' properties.

**How to Clear an Object in JavaScript**

Clearing all object properties can be a tricky task, as it involves both enumerable 
and non-enumerable properties. 
The most reliable way to do this is with the `Object.getOwnPropertyNames()` method. 
This method returns an array of all the object's property names, including non-enumerable ones. 

You can then loop through this array and `delete` each property one at a time, using either ES5 or ES6 syntax. 

In ES5, you can use a `forEach` loop to iterate through the array and `delete` each property. 

In ES6, you can use a `for-of` loop. By using this method, you can ensure that all properties of 
the object are cleared, regardless of whether or not they are enumerable.

*How Object.getOwnProperties() Works*

`Object.getOwnPropertyNames()` is a method that returns an array containing the names of all 
the properties of an object, including non-enumerable ones. 
This method is useful when you want to ensure that all properties of an object are deleted,
regardless of whether or not they are enumerable, which is very useful in our use case. 

For example, if we have an object called "obj" with properties "name", "age", and "email", we can use Object.getOwnPropertyNames() to delete all the properties of this object:

let obj = {
  name: "John",
  age: 30,
};

Object.defineProperty(obj, "email", {
  value: "john@email.com",
  enumerable: false,
  configurable: true,
});

const props = Object.getOwnPropertyNames(obj);

console.log(props);

explain the code above

The code above first creates an object called "obj" with two properties, "name" and "age". It then uses `Object.defineProperty()` to add a third property, `email`, which is non-enumerable. 
Finally, it uses `Object.getOwnPropertyNames()` to retrieve an array containing the names of all 
the object's properties, including the non-enumerable one.

The output of this code will be an array containing the strings `name`, `age`, and `email`.

```
["name", "age", "email"]
```

*ES5 Syntax Solution*

The most reliable way to clear all objects in JavaScript, even non-enumerable ones, is to use the Object.getOwnPropertyNames() method. This method returns an array of all the object's property names, including non-enumerable ones. You can then loop through this array and delete each property one at a time:

Using the `obj` from the previous example, we use the following code snippet to clear the object.

```javascript
Object.getOwnPropertyNames(obj).forEach(function (prop) {
  delete obj[prop];
});

console.log(obj); // {}
```

*ES6 Syntax Solution*

In ES6, the same logic can be applied as follows:

```javascript
for (const prop of Object.getOwnPropertyNames(obj)) {
  delete obj[prop];
}

console.log(obj); // {}
```

*Assign to Empty Object {}*

The bonus method is to assign the object to empty object `{}`.

Using the object that was defined in this article, we get the following.

```javascript
obj = {};
```

**Golang Constructors**

*Constructor Function*

A constructor function provides a way to customize the creation of an instance of an object, such 
as a `Profile`, by setting default values for fields and optionally setting values for specific fields. 
This function can be used to initialize some steps beforehand, making it easier to create objects.

```go
func NewProfile(name string, age int, email string) () {
  if age == 0 {
    age = 30
  }
  return Profile{
    name: name,
    age: age,
    email: email,
  }
}
```

This code creates a constructor function, named `NewProfile`, which is used to create a new `Profile`
instance. 
The function takes in three parameters: `name`, `age`, and `email`. If the `age` parameter is not 
provided, the constructor function will set the age to 30 by default. 
The custom constructor function then returns an instance of Profile, with the given or default 
values for each field.


In cases where constructing an object can potentially fail, custom constructor functions must 
return two values: the newly created object when successful, and a non-nil error otherwise. 
We may be dependent on other systems or libraries that could fail, so it is better to return an
error along with the initialized value.

```go
func NewProfile(name string, age int, email string) (*Profile, error) {
	if age < 0 {
		return nil, errors.New("Age cannot be negative")
	}
	return &Profile{
		Name: name,
		Age: age,
        Email: email,
	}, nil
}
```

The above code is an example of a custom constructor function which creates a `Profile` object and 
returns an error if the age is negative.


*Built-in new Function*

Go offers an alternative to manually creating a struct and assigning values to its fields: the 
built-in `new` function. This function is useful for instantiating types where no additional 
setup or initialization is required. 

As an example, here is below how to create a new pointer to a struct and set the fields of the
struct to zero values. 

```go
package main

import "fmt"

type Profile struct {
	Name  string
	Age   int 
	Email string
}

func main() {
	user := new(Profile)
	fmt.Printf("%+v\n", user)
}
```

The output of the above program is as follows.

```
{Name: Age:0 Email: } 
```

*Make Things Private*

We can use a public interface of a private struct to typehint in other packages while still 
maintaining its privacy. By having a constructor that returns the interface directly, we 
can initialise a concrete type within. 
This can be beneficial when wanting to keep the struct private while making its initialization public.

```go
package Package1

/* Exported Interface */
type SomeInterface interface {
    GetGreetings() string 
}

/* Private Struct */
type Profile struct {
    name string  
}

func NewProfile() Profile {
    return Profile{ name: "mehdi" } 
}

/* It implements the interface, so it adheres to interface type */
func (*Profile) GetGreetings() string { return "Hello there!" }
```

Typehints can be used to guarantee that another package is using a valid instance of 
`SomeInterface` and that only the `NewProfile` function can construct the object correctly. 
Unfortunately, this is not an option for objects that contain just a bunch of properties, 
since there is no way to interface them and it would be a bad practice anyway.

*Composite Literals*

Composite literals provide a straightforward syntax for initializing a struct instance in Go. 
In other words, it is a valid way to construct a struct.
For example, constructing a `Profile` struct with a `name` and `age` attributes would look like: 

```go
p := Profile{name: "mehdi", age: 29}
```

While this syntax is convenient, it does not allow for setting default values to attributes, 
thus requiring them to be repeated for each instantiation. 
Additionally, nullable attributes may be set to `nil` if not explicitly initialized, 
which can lead to errors.

Here are a couple of examples of using composite literals.

```go
// A new struct instance is created
p := Profile{}

// A pointer to a struct instance is created
pp := &Profile{}

// An empty struct is created 
nothing := struct{}{}

// Initializing a struct profile 
sami := Profile{name: "sami", age: 20}
```

*Last Words*
In conclusion, we have discussed how to create constructor functions in Go, which take 
interfaces and return structs. We have also demonstrated how to use the in-built `new()` 
function to quickly create pointers to structs without additional instantiation. 
Finally, we have explored how we can use composed literals to quickly initialize 
structs with a specific syntax.


**Use Complex Numbers in Golang**

Complex numbers can be used in Go to perform mathematical operations such as addition, subtraction, multiplication, and division. It is easy to initialize complex numbers using the constructor or the initialization syntax. Moreover, functions such as real() and imag() can be used to get the real and imaginary parts of a complex number, respectively.

*Syntax of Complex Numbers in Go*

The syntax for declaring and initializing a complex number in Go is as follows:

```go
c := complex(x, y) // this is the constructor syntax
c := x + yi // this is the complex number init syntax
```

*Real and Imaginary Parts of an Imaginary Number*
The real and imaginary parts of an imaginary number can be obtained using the `real()` and `imag()`
functions. 

The `real()` function returns the real part of the number, while the `imag()` function returns 
the imaginary part. 

For example, if we have the following complex number. 

```go
c := 10 + 11i 
```

Then we get: 

```go
r := real(c) // 10 
i := imag(c) // 11.
```

*Full Example*
Here are multiple examples of declaring complex numbers below.

```go
package main

import (
	"fmt"
)

func main() {
	// constructor syntax
	c1 := complex(10, 11)
	c2 := complex(4, 5)

	// complex number init syntax
	c3 := 10 + 11i
	c4 := 4 + 5i

	fmt.Println(c1, c2, c3, c4)
}
```

The output of the above code will be as follows. 
```
(10+11i) (4+5i) (10+11i) (4+5i)
```

*Difference complex64() and complex128()*

The main difference between the `complex64` and `complex128` types is in the size of the 
variables they store. The `complex64` type stores a 64-bit (8-byte) complex number, 
while the `complex128` type stores a 128-bit (16-byte) complex number. 
This means that `complex128` is more precise than `complex64`, and can therefore store larger numbers.

The `complex` function is an alias for `complex64`.

*What are the Allowed Operations?*

The allowed operations on complex numbers are addition, subtraction, multiplication, division, 
and taking the conjugate. 
Additionally, complex numbers can be raised to any real power and the square root can be taken.

*Last Words*

In conclusion, complex numbers can be declared and initialized in Go using either the constructor syntax or the complex number init syntax.


**How to Print Variable Names in Pyhton?**

write a paragraph about how to print a variable name using globals() in python

The globals() function in Python can be used to print a variable name. It is a built-in function that returns a dictionary of the current global symbol table. To print a variable name, access the dictionary and print the key associated with the value. For example, if you have a variable called 'myVar' with a value of 10, you can print the variable name 'myVar' by accessing the globals() dictionary and printing the associated key: print(globals()['myVar']). This will print the variable name 'myVar' to the console.

Write a sentence that introduces a code example plus the code example itself

The following code example shows how to use the globals() function to print a variable name: print(globals()['myVar']).

Write a full code script in python that shows how to print a variable name using globals() where we know just the value of the variable and not its string representation

myVar = 10

# Print the variable name associated with the value of 10
print(globals()[list(globals().keys())[list(globals().values()).index(10)]])

use list comprehension instead

myVar = 10

# Print the variable name associated with the value of 10
print([k for k,v in globals().items() if v == 10][0])

What happens if two variables have the same value?

If two variables have the same value, the globals() function will return a list of the variable names associated with that value. For example, if two variables, 'myVar1' and 'myVar2', both have a value of 10, globals()['myVar1', 'myVar2'] will return a list containing both variable names.

write an example of this case

myVar1 = 10
myVar2 = 10

# Print the variable names associated with the value of 10
print(globals()['myVar1', 'myVar2']) # Output: ['myVar1', 'myVar2']

**How to Split a List in Two in Python?**

**How to Add Integers to a List in Python?**

You can employ the `append()` list method to put an integer at the end of a list, as an example 
`nums.append(10)`. 
Moreover, `extend()` allows you to include multiple integers in one go. 
And also, an integer at a specific index can be added using the `insert()` function.

*Example using append(), extend() and insert()*

A complete example code appears like this:

```python
nums = [1, 2, 3]


nums.append(10)
print(nums)


nums.extend([22, 89])
print(nums)


nums.insert(1, 20)
print(nums)
```

The output of the program is as follows.
```
[1, 20, 2, 3, 10, 22, 89]
```

The first example is using the `append()` function from the list object to add an integer at 
the end of the list, in this case the value 10. 
The second example uses the `extend()` function to add multiple integers at the end of the list, 
in this case the values 22 and 89. 
The last example is using the `insert()` function to add an integer at the specific index 
of the list, in this case a value of 100 at index 0.

**Explaining FusedIterator Trait in Rust**

Today's article are personal notes that I've gathered about the trait `std::iter::FusedIterator`
in rust. 

*Syntax*

Here is the syntax.

```rust
pub trait FusedIterator: Iterator { ... }
```

*What is FusedIterator?*
The FusedIterator trait is a way of saying that when an iterator (something that 
can go through a list of items) has reached the end, it will always stay at the end 
and not start again. 
This trait helps optimize the code that uses the iterator, so that it runs faster.

In other words, the trait is an extension of the `Iterator` trait `FusedIterator: Iterator` 
that ensures that when a particular iterator has reached the end of a list of items, 
it will not iterate over them again.

*Should we Use FusedIterator in Generic Bounds?*

Using the `FusedIterator` in generic bounds is not recommended when you need a fused iterator. 
The better option would be to call `Iterator::fuse()` on the iterator. 
This Fuse wrapper will have no effect on the performance if the iterator is already fused.

*Last Words*

The `FusedIterator` trait is a useful tool for optimizing iterators so that code that uses 
them can run faster. It is important to remember that it should not be used in generic 
bounds if a fused iterator is needed, but instead, `Iterator::fuse()` should be called on the iterator.

That's all for now. I will be adding more information as I practice using more.


**How to Use Git Log to Find Changes You Know You Made**

We’ve all been there; you’ve worked hard on a project and you’re sure you wrote something but 
it’s no longer there. It did happen to me so many times! 
What to do? 

Luckily, there’s a solution for this. The command `git log` allows you to find changes on a 
particular file across branches so you can easily find the changes you know you made.

*Git Log*

Git log is a useful command that allows you to search through all of your commits for a particular file. 
All you have to do is enter the command:

```bash
git log --all --source -- path/to/my/file
```

And you’ll be able to find any changes you’ve made to that file in the past.

This is especially useful if you’ve made changes to a file on one branch and then forgot to merge those changes to another branch. So you find it, even if they’re not in the branch you’re currently working on.

*Example*

Here is an example command.

```bash
git log --all --source -- path/to/my/file
```

Here is an example output. 

```
commit 4c9dd9b30f8b95cc0d47e092fdbba2a8c2e7cdfc
Author: John Doe <john.doe@example.com>
Date:   Tue Mar 23 11:06:47 2021 +0700

    Updated myfile.txt to include new feature

commit 8f6a2a1aad8f8c3d3b59c3f9b9f3220c3d4f71bc
Author: John Doe <john.doe@example.com>
Date:   Tue Mar 16 11:06:47 2021 +0700

    Added new feature to myfile.txt
```

*Benefits and Usecases*

Using Git log is a great way to make sure that you’re always able to find the changes you know you made. 
It’s also a great way to keep track of all the changes you’ve made to a particular file over time.

Plus, if you ever need to go back and look at a particular change you made, you can easily do so with Git log. 
You are sure to be working with the most up-to-date version of a file.


**What is Gap Property in CSS?**

Today, I've learned about the `gap` css property and decided to share this handy tip with you.

The gap property in CSS is a shorthand for setting the distance between flex items. 
It combines the `row-gap` and `column-gap` properties, allowing developers to specify the 
spacing between items in a flex container. 

For example, the code below specifies a gap of 3em between flex items: 

```css
.flex-container-gap {
  display: flex;
  flex-direction: column;
  gap: 3em;
}
```

The gap property is a great way to quickly set the spacing between flex items in a container, 
as it saves developers the time of having to set the `row-gap` and `column-gap` properties separately
as shown in the example CSS class in this article. 

**How Find Branches that Contain a Sha?**

Today, I've learnt how to find the branches in a git repository with a given commit sha.

You can use the `git branch --contains` command. This command will search all of the branches in 
your repo and return any branches that include the specified commit sha. 
You can also use this command to find out how many branches in your repo contain the specified commit sha. 

It is especially helpful if you are working with a large repo and need to quickly find out 
which branch a certain commit belongs to.

*Syntax*

The syntax for this command is as follows:

```shell
git branch --contains <commit-sha>
```

*Example*

For example, if you want to find out which branches in your repo contain the commit sha `abcd123`, 
you would use the following command:

```shell
git branch --contains abcd123
```

The output of this command would be a list of all the branches in your repo that contain 
the commit sha `abcd123`.

Here is a sample output.

```text
master
develop
feature/example-feature
```

**How to Sort Git Branches using Latest Commit?**

Today, I've learnt how to sort branches by latest commit and will let you syphon all my recently
acquired knowledge in this article.

When many branches are stored in your repository, it can be difficult to keep track of the latest commits. 
But there is a command that could help you do just do that.
In order to sort your branches by the most recent commit, here is the command to use: 

```shell
git for-each-ref --sort=-committerdate --format="%(refname:short)" refs/heads/ 
```

The above command iterates over each branch and sorts them by the most recent commit. 

A sample output is provided below. 

```
feature/pr-3979
some_branch
master
```

The order of the branches indicates that the latest commit was made to the `feature/pr-3979` 
branch, followed by the `some_branch` branch, and then the `master` branch.


*Show Only One Branch*

You can also filter the output of this command to view only the latest commit. 
To do this, add the `--count` argument to the command. 
This will limit the output to the most recent commit.

The command's syntax is as follows. 
```shell
git for-each-ref --sort=-committerdate --count=1 --format="%(refname:short)" refs/heads/
```

```
feature/pr-3979
```

*Last Words*
This is a quick and easy way to sort your branches by the latest commit. 
With this command, you can easily view which branches have the most recent changes 
and use that information to plan your next development task.

**How to Switch Branches in Git**

Switching to a new git branch can be done using two methods. The first method, 
which is widely used, is to run `git checkout`. The newer method is to use the 
command `git switch`, which accomplishes the same goal in a more intuitive way.

*Before Git Switch*

Git provides an easy way to switch to a different branch with the `git checkout` command. 
To switch to an existing branch, simply run:

```bash
git checkout <branch_name> 
```

To create a new branch and switch to it, run:

```bash
git checkout -b <branch_name>”
```

If the branch does not exist, you will get an error message. 
Once the branch has been created, you can switch to it successfully.

Here is an example.

To switch to an existing branch named `feature002`, you would run:
```bash
git checkout feature002
```

To create a new branch named `development3`, you would run: 

```bash
git checkout -b development3
```

*With Git Switch*

The `git switch` command can be used to quickly switch between branches. 
If the destination branch does not exist, the `-c` option must be specified to create the branch. 


Now, let's see how it works through two examples.

```bash
git switch feature002
```
This command switches the current branch to the `feature` branch. If the `feature` branch already 
exists, this command will switch to it.

```bash
git switch -c does-not-exist
```

This command creates a new branch called `does-not-exist`, through the use of the `-c` flag, 
and switches to it. This is useful if you want to create a new branch and start working on it.


**How Bulk Delete Branches in Git with Confirmation?**

I'm often faced with the challenge of managing a lot of remote branches when I am working on my projects. 
It can be difficult to keep track of them all and make sure everything is up to date. 

In order to get past this challenge, I use the `git branch` command to clean up branches I don't need anymore. 

Here is the somewhat complicated command that can be run to accomplish that:

```bash
git branch -a | grep remotes | awk '{gsub(/remotes\/origin\//, ""); print;}' | xargs -I % -p git push origin :%
```

This command will run through all the remote branches and prompt for confirmation before deleting each one. 
This way, developers can be sure they only delete the branches they intended to remove.

So make good use of this command as it can save you a lot of time and hassle when managing a large number of git repos, by keeping them clean and organized.


**What Value is a 'char' Type in Rust?**

A `char` type in rust represents a `Unicode Scalar Value`. 

*What is a Unicode Scalar Value?*

A Unicode scalar value is a single Unicode code point that can be represented by a 
single 16-bit number. It is a unique integer value assigned to a character, and is 
used to represent any character in the Unicode character set, including non-printable control characters.

Here are examples of unicode scalar values:
```
U+0000 to U+D7FF
U+E000 to U+10FFFF
```

*What is a Char in Rust?*

A `char` type is a primitive type in Rust that represents a Unicode scalar value. 
This type is four bytes in size and can store any Unicode scalar value, including emoji and 
other special characters. `Char` is also used for single characters, such as the letter 'a'.

Here are char examples below.

```rust
let c: char = 'a';
let emoji: char = '😃';
```

**How to Split String by Tab in Python**
**How to Split a String by Comma in Pyhton**
**How to Split a String by Colon in Python**
**How to Split a String by Hyphen in Python**
**How to Split a String into a List in Python**
**How to Split a String by Empty Line in Python**
**How to Split a String by Semicolon in Python**
**How to Split a String by Backslash in Python**
**How to Split a String by Underscore in Python**
**How to Split a String by Forward Slash in Python**
**How to Split a String by Whitespace in Python**
**How to Split a String on Uppercase Letters in Python**
**How to Split a String on Punctuation in Python**
**How to Split a String on Newline Characters in Python**



**How to Declare Constants in Rust**

In this article, I will summarize what I've had to understand so far about constants and how to declare them
in the rust programming language.

As we all know, constants are part of most programming languages nowadays as they help define immutable values 
that can be used across the program. 

And in particular in Rust, constants can be divided in two distinct parts: global constants and static constants.
Global constants are immutable and cannot be modified, while static constants can be made mutable and have 
a `static` lifetime. 

I will detail in the following how to declare and use constants in rust.  

*Declaration Syntax of Constants*

Here is how to declare a global constant in rust. 

```rust
const name: type = value;
```

Important Note: You must explicity specify the type of the constant, unlike in other parts of a rust 
program.

Constants are a great way to define values that do not need to be changed by other parts of the program.

The other syntax for a constant in rust is through the use of the `static` keyword.

```rust
static name: type = value;
```

*Examples of Declaration of Constants*
 
Global constants are unchangeable values that all parts of the program can use. To declare a global 
constant, the const keyword is used followed by the name of the variable, its type, and the value. 
For example: 

```rust
const PI: f64 = 3.1415926535;
fn main() { 
  println!("{}", PI*10); 
}
```

Static constants can be made mutable, through the use of the `mut` keyword, but contain a 
static lifetime that must be annotated. 

An example of a static constant is shown below: 

```rust
static AGE: u32 = 21;
fn main() { 
  println!("My age is {}", AGE); 
}
```

*Last Words*

We have covered the basics of constants in Rust. Constants are used to define immutable values 
that can be used across the program. 
There are two types of constants: global constants and static constants. 
Global constants are immutable and cannot be modified, while static constants can be made mutable 
but contain a static lifetime.


**CORS For Software Developers**

I've struggled to understand CORS for developers, so I'm writing this article to explain it.

*What is CORS?*

Cross-Origin Resource Sharing (CORS) is a browser feature that enables clients to load external server-side 
resources from different origins by reading HTTP headers. The cross-origin request will reach the 
server regardless, as it needs to determine whether to return the response to JavaScript based on the 
HTTP headers returned by the server. 
Depending on the type of request, simple requests and preflight requests, the corresponding backend 
feature will be executed. 

*CORS Explained to a Five Years Old*

Cross-Origin Resource Sharing (CORS) is a way for websites to share information with each other. It 
works by letting a website ask another website for information. The other website then looks at the 
request and decides if it can share the information or not. It does this by looking at the special 
instructions (HTTP headers) that come with the request. 
And the website that contains the information to be shared can decide, depending on the type of request, to
do something special to make sure it is safe to share the given information.


*CORS Error Example*

The browser console can indicate if a CORS configuration isn't setup correctly by showing an error 
related to the `Same Origin Policy`. If the endpoint is supposed to be available, some 
debugging is necessary to resolve the issue.

Here is an example error message.
```
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite
```

This error indicates that the browser is blocking a request due to violating the CORS security rules. 
This could be due to a misconfigured CORS setup, or it might be intentional. If the remote 
endpoint is meant to be available, further debugging is needed to resolve the issue.


*How to Fix CORS Errors*

When encountering a CORS configuration issue on a web site or web app, the initial step is to open the 
Developer Tools and attempt to replicate the failing transaction. 
If a CORS violation error message appears, it will be similar to this:

```
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource 
at some-url-address (Reason: more information is provided here...).
```

For security reasons, the exact details of what went wrong with the CORS request are not available 
to JavaScript code. The only way to determine what exactly happened is to check the browser's 
console for more information.

*CORS Request*
*CORS Response*


*CORS Error Reasons List*

The browser's console will provide a reason message when requests fail due to a CORS policy. 
These reasons include: 

```
Reason: CORS disabled
Reason: CORS request did not succeed
Reason: CORS header 'Origin' cannot be added
Reason: CORS request external redirect not allowed
Reason: CORS request not http
Reason: CORS header 'Access-Control-Allow-Origin' missing
Reason: CORS header 'Access-Control-Allow-Origin' does not match 'xyz'
Reason: Credential is not supported if the CORS header 'Access-Control-Allow-Origin' is '*'
Reason: Did not find method in CORS header 'Access-Control-Allow-Methods'
Reason: expected 'true' in CORS header 'Access-Control-Allow-Credentials'
Reason: CORS preflight channel did not succeed
Reason: invalid token 'abc' in CORS header 'Access-Control-Allow-Methods'
Reason: invalid token 'abc' in CORS header 'Access-Control-Allow-Headers'
Reason: missing token 'abc' in CORS header 'Access-Control-Allow-Headers' from CORS preflight channel
Reason: Multiple CORS header 'Access-Control-Allow-Origin' not allowed
```

The console provides these error messages to provide more insight into what went wrong.

*Potential Solutions*

The obvious solution is to enable CORS on your server.
You need to enable CORS on your server in order to allow browsers to make cross-domain requests. 
There are several ways to do this, depending on the server you’re using. 
For example, if you’re using Apache, you can use mod_headers to enable CORS.

You can use a proxy server.
If you don’t want to enable CORS on your server, you can use a proxy server to make the request. 
A proxy server is a server that acts as an intermediary between the client and the target server. 
This allows the client to make requests to a different domain without violating the same-origin policy.

You can use JSONP.
JSONP (JSON with Padding) is an older technique for making cross-domain requests. It works by 
adding a `<script>` tag to the page that contains a query string parameter pointing to a URL on the 
target domain. The response is then returned as a JavaScript script, which can be executed 
in the page.

Also, it is possible to use subdomains.
If you own both the source and the target domains, you can use a subdomain to make the request. By 
setting the `Access-Control-Allow-Origin` header to the subdomain, you can bypass the same-origin policy. 
This is a good solution if the data you’re requesting is public and doesn’t need to be authenticated.


**Does Golang Support Optional Function Parameters?**


Short answer is no.

Go does not feature optional parameters nor does it allow for method overloading. This decision 
was made to make the type system simpler, preventing confusion and fragility that methods with the 
same name but different signatures could bring in other languages. Instead, Go only matches methods
by their name and requires consistency in the types.

*Alternative: Variadic Parameters*

As shown in the example below, we demonstrate the use of the function `foo` with no parameters, 
one parameter, and three parameters. 
Calling the function with no parameters, one parameter, or multiple parameters,
 we can see that `foo` takes optional parameters of type int through variadic args. 

```go
package main

import "fmt"

func foo(args ...int) {
    fmt.Println(args)
}

func main() {
    foo()
    foo(1)
    foo(1,2,3)
}
```

The limitation of this approach is that we can use only the same type for all parameters.

*Alternative: Struct with Parameters*

A struct which includes the parameters can be used to make calling a function with multiple parameters easier. 
The struct, called `Params`, contains the parameters `a`, `b`, and `c`. When calling the function `foo`, 
the struct can be passed instead of specifying each parameter. 
This has the advantage that different types of parameters can be used with the `Params` struct over the `foo(...params)`
solution. 

To call the `foo` function with only two params, one can simply write `foo(Params{a: 1, c: 9})`.

```go
package main

import "fmt"

type Params struct {
  a, b, c int
}

func foo(p Params) int {
  return p.a + p.b + p.c 
}

func main() {
  params := Params{a: 1, c: 9}
  
  result := foo(params)

  fmt.Println(result) // 10 
}
```

**Nameless and Anonymous Fields in Golang**

I must confess that this is such a surprising property of structs which is provided in Golang.


*What are Anonymous Fields?*

Nameless and anonymous fields allow a struct to have fields that do not have a name. 
Instead, they are identified by their `type`. 

This allows developers to add fields of any type without having to give them a name. 
In the following, I will share a couple of examples of how it works.


*Anonymous Fields Syntax*

Here is the syntax of anonymous fields shown below.

```go
struct {
	[name] [type]
	[anonymous field type]
	[anonymous field type]
}
```


*Examples*

For instance, if a struct has an anonymous `int` field, 
it can contain any string value without having to declare a specific name for it.

```go
type MyStruct struct {
	int
}

func main() {
	s := MyStruct{5}

  fmt.Println(s.int) // 5
}
```

Anonymous fields are useful in Golang when dealing with inheritance and composition. For instance, 
a struct can contain fields from another struct without having to explicitly declare them.

Here is an example of a struct with a `string` anonymous field.

```go
type MyStruct struct {
	string
}

type AnotherStruct struct {
	MyStruct
}

func main() {
	s := AnotherStruct{MyStruct{"Foo"}}
	fmt.Println(s.string) // Foo
}
```

Using anonymous fields can help reduce the amount of code needed to define a struct, 
as well as make it easier to understand the structure of a struct.


*Used for Inheritance and Composition*

Anonymous fields are also useful when dealing with embedded interfaces. For example, 
a struct can have fields that implement an interface without having to explicitly declare them.

```go
// Example of anonymous struct with interface
package main

import "fmt"

type MyInterface interface {
	MyMethod()
}

type MyImpl1 struct {}

func (m *MyImpl1) MyMethod() {
	fmt.Println("MyImpl1.MyMethod")
}

type MyImpl2 struct {}

func (m *MyImpl2) MyMethod() {
	fmt.Println("MyImpl2.MyMethod")
}

type MyStruct struct {
	MyInterface
}

func main() {
	s1 := MyStruct{&MyImpl1{}}
  s2 := MyStruct{&MyImpl2{}} 	
  
  s1.MyMethod() // MyImpl1.MyMethod
  s2.MyMethod() // MyImpl2.MyMethod
}
```

*Last Words*

In summary, anonymous and nameless fields in Golang allow developers to add fields of any type without having 
to give them a name. 
This can help reduce the amount of code needed to define a struct, as well as make it easier to 
understand the structure of a struct. 

They can also be used when dealing with inheritance and composition, as well as embedded interfaces.

**How to Check if a File Exists in Go/Golang**

In today's article, we will look at how to check if a file exists in Go/Golang. 
This is one of the most asked questions in stackoverflow and in golang forums, so I decided to write an article 
to explain how it works.

The gist of the operation is to use the `os` package which includes the functions `Stat()`, `IsExist()` and `IsNotExist()`
in order to perform the check.

*Combining os.Stat() and os.IsNotExist()*

The `os` package provides the `Stat()` function which can be used to check for the existence of a file. 
The `Stat()` function takes the path to the file as an argument and returns a `FileInfo` object if successful. 
This `FileInfo` object can then be used to check the type of the file and other information about the file. In our 
case, we don't need this information.

However, in case there is an error while trying to access the file, the `Stat()` function returns a non-nil `error` object. 
To check the type of error, the `os.IsNotExist()` function can be used. The `os.IsNotExist()` function returns `true` if 
the error is due to the file not existing. The other function returns `true` if the error is due to the file already being 
there.

By combining the methods `os.Stat()` and `os.IsNotExist()`, we can check if a file exists in Golang:

```go
if _, err := os.Stat(path/to/file); !os.IsNotExist(err) {
  // code when file exists 
} 
```

In the above code, the `Stat()` function is used to check for the existence of a file at the given path. 
If the file does not exist, then the `Stat()` function returns a non-nil error. The `os.IsNotExist()` 
function is then used to check if the error is due to the file not existing. 
If the error is not due to the file not existing, the `os.IsNotExist()` a returns `false`, and 
the code inside the `if` block is executed.

In that sense, the `os.IsExist()` means that the error is due to the file existing. But then, we are missing the 
case where the file exists and does not cause an error, and returns a `FileInfo` object. 

The equivalent code using the function `IsExist()` is as follows.

```go
if _, err := os.Stat(path/to/file); err == nil || os.IsExist(err) {
  // code when file exists 
} 
```

As this function is a little more verbose than the first version. We will go with the first check for 
our helper function below.

*Helper Function*

We can also write a simple helper function to determine if a file exists or not. 
The following code creates a function called `FileExists()` which takes a file path as an argument and returns a boolean value indicating if the file exists or not:

```go
func FileExists(filename string) bool {
	if _, err := os.Stat(filename); !os.IsNotExist(err) {
		return true
	}
	return false
}
```

The helper function This function uses the `Stat()` and `IsNotExist()` functions from the `os` package 
to check if a file exists or not. The function returns a boolean value; `true` if the file exists 
and `false` otherwise. 

Here is in the following an example that shows how to use the `FileExists()` to check if a file exists.

```go
package main 

import (
  "os"
  "fmt"
)

func FileExists(filename string) bool {
	if _, err := os.Stat(filename); !os.IsNotExist(err) {
		return true
	}
	return false
}

func main() {
	filename := "test.txt"
	if fileExists(filename) {
		fmt.Printf("File %s exists\n", filename)
	} else {
		fmt.Printf("File %s does not exist\n", filename)
	}
}
```

In the above code, we call the `FileExists()` function to check if the `test.txt` file exists or not. 
If the file exists, the message "File test.txt exists" is printed, otherwise, it prints the message 
"File test.txt does not exist". 

*Last Words*

We looked at how to check if a file exists in Go/Golang. We discussed the usage of the `os` package's `Stat()` 
function and the `os.IsExist()` and `os.IsNotExist()` functions to check if a file exists. 
We also wrote a simple helper function to make the checking process easier that you can use as is.



**1) How to Include a Module From Another File in Rust?**

Today, we will answer the question `How to include a module from another file in rust?`.

First, we will define what a module is.

*What is a Module?*

A Rust module is a collection of items such as functions, structs, traits, and implementations that 
have been grouped together (usually in a file). 
Modules allow for better code organization and reuse, as well as more powerful abstractions. 

*Is a File a Module in Rust?*

Yes, a file in Rust can be a module. A file in Rust can also contain nested modules that are declared with
the `mod` keyword. If the file contains functions, structs, traits, and their implementations, then it is a 
module.

*Answer*
Including files in Rust is a way to organize and modularize your code (the other option is put everything in main!). 
So to answer the question, you will need to make use of the `use` statement in rust to include external and internal files
and items. 

In our case, we are trying to include files and items from the same crate, we can make use of the `super::` keyword in 
conjonction with the `mod` keyword.

Let's consider the following directory structure:
```
src
├── main.rs
├── my.rs
└── my
    ├── a.rs
    └── b.rs
```

Here is the content of the `a.rs` file.

```rust
pub fn foo() {
  println!("Hello world!");
} 
```

To include the file `src/my/a.rs` in `src/my/b.rs`, you would use the following syntax:
```rust
use super::a::foo;

pub fn baz() {
  println!("Hello from baz!");
  foo();
} 
```
This would allow you to call the function defined in `a.rs` from `b.rs`. 

Using the `super::` keyword to include files from the same directory is a way to keep your code organized and modular. 

Now, let's see how to include both files in `my.rs`.

```rust
mod a;
mod b;
```

Finally, here how to use both modules by importing simply the `my` module in the main function.

```rust
mod my;

fn main() {
  my::foo();
  println!("----------");
  my::baz();
}
``` 


**pub vs pub(crate) in Rust**

I've seen this questions asked often by aspiring rustaceans:
```
What is the difference betwen the keywords `pub` and `pub(crate)`?
```

*Answer*

The `pub` and `pub(crate)` keywords in Rust are two differents ways to make items available in a crate. 


Difference: The `pub` keyword is used to make items available `outside` of the current crate, while the `pub(crate)` keyword 
makes the item only available `within` the current crate. 

*pub Keyword*
In other words, the `pub` keyword is used to make items available for use within a crate, as well as making them 
available for use outside of the crate. This includes functions, structs, traits, and modules. 
For example, the following code would make the `foo` module available outside the current crate. 

```rust
pub mod foo;
```

*pub(crate) Keyword*

The `pub(crate)` keyword is used to make items available only within the current crate, and not outside the crate. 
This is useful for items that should not be exposed outside the current crate, such as 
private functions, structs, and traits. 
For example, the following code would make the `baz` module available only within the current crate. 

```rust
pub(crate) mod baz;
```

*Last Words*

In summary, the `pub` and `pub(crate)` keywords in Rust are used to make items available within and outside a crate, 
respectively.

**How to Join Vector of Strings in Rust?**

In today's short article, I will show you how to join a vector of strings in rust.

The `join` operator is the solution. It is a commonly used tool when working with strings. 
In Rust, the `join` operator can be used to join a vector of strings into a single string. 
This is accomplished using the `join()` method on the vector of strings. 
This is due to `Vec` implementing the trait `SliceConcatExt::join`.

The syntax for this is as follows:

```rust
let strings: Vec<String> = vec!["string1".to_owned(), "string2".to_owned(), "string3".to_owned()];
let result = strings.join("-");
```

In this example, the `join()` method is used to join the strings in the vector together, and the `-` character 
is used as the delimiter between the individual strings. 

The result of the join() method is a single string containing the joined strings, separated by the delimiter character.

```rust
fn main() {
  let strings: Vec<String> = vec!["string1".to_owned(), "string2".to_owned(), "string3".to_owned()];
  let result = strings.join("-");
  
  assert_eq!("string1-string2-string3".to_owned(), result);
}

```

*Last Words*

The join operator is a powerful tool that can be used to quickly combine multiple strings into a single string. 
This can be useful in situations where multiple strings need to be combined into a single string, such as 
when building URLs, generating HTML code, or when constructing SQL queries. 



**What is The Question Mark Operator (?) in Rust?**

The question mark operator (`?`) is a postfix operator in Rust that is used to 
unwrap `Result<T, E>` and `Option<T>` values. 
The aim is to simplify the code and make it more readable/maintanable.

When applied to `Result<T, E>`, it will unwrap the result and give you the inner value, 
propagating the error to the calling function. 

For example, the following code will print out `346`.

```rust
let num = "346".parse::<i32>()?;
println!("{:?}", number); // 346 
```

When applied to an `Option<T>`, it will propagate `None` to the caller, leaving you the content of the 
`Some` branch to deal with. 

Here is an example that will also print `346`.

```rust
let val = Some(346)?;
println!("{:?}", val); // 346 
```

The `?` operator can only be used in a function that returns `Result` or `Option`. 

Here is a complete program that can be compiled and executed (use the online playground) 
to show how the `?` operator works.

```rust
fn main() -> Result<(), Box<dyn std::error::Error>> {
  let num = "346".parse::<i32>()?;
  println!("{:?}", num);
    
  Ok(())
}
```

*Last Words*

The `?` operator is a great convenience offered by Rust and eliminates boilerplate code, which makes implementing
functions simpler.

*Difference Between Copied() and Cloned() in Rust*

*What is Copied() in Iterator?*

The `iter().copied()` method creates an iterator that clones each element of the original iterator by 
simply copying the data from one place to another, which is a shallow copy. This can be used to 
create a new vector from an existing vector, for example. 
The elements of the vector needs to implement the `Copy` trait.

Example of usage of the `copied()` function.

```rust
let v = vec![1,2,3];
let copied_v: Vec<u32> = v.iter().copied().collect();
```

`copied_v` is now a new vector containing the elements of v, with all elements copied

*What is Cloned() in Iterator?*

On the other hand, the `iter().cloned()` method creates an iterator that clones each element of the original 
iterator by creating a new object with a copy of all the data of the original object, which is a deep copy. 
This is useful when the object contains references to other objects, as the new object will be completely 
independent of the original object.
Note that all the elements of the vector needs to implement the `Clone` trait.

```rust
let v = vec!["one".to_owned(), "two".to_owned(), "three".to_owned()];
let cloned_v: Vec<String> = v.iter().cloned().collect();
```

```rust
// fast 
let do_that: Vec<String> = v.iter().filter(|x| x.eq("two")).cloned().collect();
// slow 
let dont_do_that: Vec<String> = v.iter().cloned().filter(|x| x.eq("two")).collect();
```

*What is the Equivalent of Copied using Map?*

The equivalent of copied using `map()` is as follows.
```rust
let v = vec![1, 2, 3, 4, 5];

let res_copied: Vec<u8> = v.iter().copied().collect();

let res_map: Vec<u8> = v.iter().map(|&x| x).collect(); 

assert_eq!(res_copied, res_map);
```

**[FIXED] error[E0308]: can't compare String with &str**

I've learnt something today: pattern matching uses a different comparison logic
than the equality operator in rust.

*Problem*

Here is the problem when using a `match` block in rust.

```rust 
fn main() {
    let s = String::from("hi");

    match s {
        "hi" => println!("it worked!"),
        _ => panic!("wrong value!"),
    }
}
```

This triggers the following error. 

```
error[E0308]: mismatched types
  --> src/main.rs:12:9
   |
11 |     match s {
   |           - this expression has type `String`
12 |         "hi" => println!("it worked!"),
   |         ^^^^ expected struct `String`, found `&str`
```


*Solution*

Now, if we were to compare a `String` with a string slice `&str`, it would work.

```rust
let result = String::from("hi") == "hi";
assert_eq!(true, result);
```

But the `match` block uses `pattern matching` which does not use the same logic as the 
equality operator `==` and its implementation for the respective types above.

The solution is to convert the `String` to a `&str` using the following syntax.

```rust
fn main() {
    let s = String::from("hi");

    match &s[..] {
        "hi" => println!("it worked!"),
        _ => panic!("wrong value!"),
    }
}
```

**Can Rust Function Have Default Argument Values?**

Multiple aspiring rustaceans wondering whether it was possible, like in other languages, to have default argument
values for rust, and they proposed the following syntax.

```rust
fn add(a: usize = 1, b: usize = 2) -> usize { 
  a + b 
}
```

But this syntax won't compile. Here are a couple of solutions to define default values for functions in rust.


*Solution*
In the following, here is the solution to use default arguments in Rust. 

Although there is no native syntax to do so, there are various ways to achieve a similar outcome in Rust.

The most basic way is to use `Option<T>` for arguments. This allows you to specify a default value that 
will be used if the argument is not passed in. This requires more typing out, but it is explicit 
and prevents the caller from forgetting to make a choice.

On the other hand, you can also rely on rust macros to produce similar results. The macro will match 
patterns in the argument list and use the specified defaults if no argument is passed in. 
This is how `println` macro, under the hood, is able to permit variadic parameters.

Finally, you could use a `arguments` struct and the `From/Into` traits. This is the solution that 
requires the most code, but it allows you to use the type system to get more helpful compiler errors. 
It also allows users to make their own `From` implementation if that is helpful to them.

Here is the first solution using `Option<T>`.

```rust
fn add(a: Option<i32>, b: Option<i32>) -> i32 {
    a.unwrap_or(1) + b.unwrap_or(2)
}
```

The function call will look like `add(None, None)`, which you looks awkward to say the least.

Here is the second method which uses a macro. The syntax is already much better.

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}

macro_rules! add {
    ($a: expr) => {
        add($a, 4)
    };
    () => {
        add(1, 4)
    };
}

assert_eq!(add!(), 5);
assert_eq!(add!(4), 8);
```

Here is the solution that is the most involved which allow you to implement the behavior of `arguments` using the 
`From/Into` traits. 

```rust
pub struct AddArgs {
    a: f64,
    b: i32,
}

impl Default for AddArgs {
    fn default() -> Self {
        AddArgs { a: 2.0, b: 2 }
    }
}

impl From<()> for AddArgs {
    fn from(_: ()) -> Self {
        Self::default()
    }
}

impl From<f64> for AddArgs {
    fn from(a: f64) -> Self {
        Self {
            a: a,
            ..Self::default()
        }
    }
}

impl From<i32> for AddArgs {
    fn from(b: i32) -> Self {
        Self {
            b: b,
            ..Self::default()
        }
    }
}

impl From<(f64, i32)> for AddArgs {
    fn from((a, b): (f64, i32)) -> Self {
        Self { a: a, b: b }
    }
}

pub fn add<A>(args: A) -> f64
where
    A: Into<AddArgs>,
{
  let args = args.into();
  args.a * (args.b as f64)
}

fn main() {
  println!("{}", foo(()));       // 4
  println!("{}", foo(4.0));      // 8
  println!("{}", foo(-3));       // -6
  println!("{}", foo((2.0, 6))); // 12
}
```

**How to Clone an Object in Modern JavasCript**

I was fed up of using the `JSON.serialize()` and `JSON.parse()` hack to deep clone objects in JavaScript.

The gods of ECMAScript were finally receptive and we've got a new cool toy to play with that allow
use to deep copy about anything in JavaScript, I named `structuredClone()`.

*What is structuredClone()?*

Structured Clone is a new API that simplifies the process of deep cloning objects in JavaScript. 
It is a tool that enables developers to create a copy of an object that is completely independent 
of the original object. This provides a way to maintain the integrity of the original object while still 
allowing the user to access the data stored within it.

The Structured Clone API utilizes the structured cloning algorithm to create a complete copy of an object. 
This algorithm is able to recognize the different types of objects and data stored within the original object 
and create a completely independent copy. This means that the original object and the clone can be used 
and modified independently of one another.

In addition to allowing developers to clone objects, the Structured Clone API also enables them to clone 
more complex types of data such as `Date` objects, `Blobs`, `File` objects, `ImageBitmap` objects, and 
even `RegExp` objects. 

The Structured Clone API is a relatively new API, so it is important to use a build tool that provides 
core-js (babel) polyfills if you intend to use it in the browser. This will ensure that all of the necessary 
code is included to make the API work correctly.

*structuredClone() Examples*

The first example clones the good old plain javascript object.

```javascript 
// Create an object to clone
let originalObject = {
  name: 'John',
  age: 25,
  job: 'Engineer'
};

// Use Structured Clone to create a clone of the object
let clone = structuredClone(originalObject);

// Modify the clone without affecting the original object
clone.name = 'Jane';
clone.age = 26;

// The original object remains unchanged
console.log(originalObject.name); // John
console.log(originalObject.age); // 25
```

Here is another example cloning a date. 

```javascript
// Create a Date object to clone
let date = new Date();

// Use Structured Clone to create a clone of the Date
let cloneDate = structuredClone(date);

// Modify the clone without affecting the original date
cloneDate.setDate(cloneDate.getDate() + 1);

// The original date remains unchanged
console.log(date.toDateString()); // Today's date
```

Example of cloning a blob is below.

```javascript
// Create a Blob object to clone
let blob = new Blob(['Hello World!']);

// Use Structured Clone to create a clone of the Blob
let cloneBlob = structuredClone(blob);

// Modify the clone without affecting the original Blob
cloneBlob.size += 1;

// The original Blob remains unchanged
console.log(blob.size); // 12
```

**What is Resource Aquisition is Initialization (RAII)?**

Resource Acquisition is Initialization (RAII) is a programming technique used to manage resources in a 
program. It is a concept that has been around for decades, but has recently seen a resurgence of interest 
due to its strong ties to modern object-oriented programming (OOP) languages such as C++ and Rust. This 
article will explain what RAII is, the benefits of using RAII, and how it is implemented in different 
programming languages.

*What is Resource Acquisition is Initialization (RAII)?*

At its core, Resource Acquisition is Initialization (RAII) is a programming technique used to manage resources 
in a program. This includes memory, files, networks, and other resources. 
RAII works by tying the life cycle of a resource to the life cycle of an object. When an object is created, it 
acquires the resource, and when the object is destroyed, the resource is released. This ensures that resources 
are always managed properly and never become “leaked” or forgotten.

*Benefits of Using RAII*

One of the biggest benefits of RAII is improved memory management. By tying the life cycle of a resource to the 
life cycle of an object, RAII eliminates the need for manual memory management in a program. So, in other
needs, there is no need to use a garbage collector that would run on top of the program runtime itself.

In addition to improved memory management, RAII also reduces the complexity of code. Because the life cycle of 
a resource is managed by the object, the code for managing resources is simplified and can be written in 
a more straightforward way, which simplifies the maintanability and debugability of te code.

Finally, RAII increases the reliability of a program. By ensuring that resources are always managed properly and 
never forgotten, RAII helps to prevent memory leaks, deadlocks, and other issues which can cause a program to crash.

For instance, Discord switched their backend infrastructure code from Golang to Rust in order to reduce latency 
caused by the go's garbage collector's overhead.

*RAII in C++*

RAII is widely used in modern C++ programming. In C++, RAII is implemented using two types of smart pointers: 
`unique_ptr` and `shared_ptr`. 
A `unique_ptr` is a pointer which manages a single resource. When it is destroyed, the resource is automatically 
released. 
A `shared_ptr` is similar to a unique_ptr, but it can manage multiple resources at once.

In addition to smart pointers, C++ also provides a way to implement RAII using scoped locks. A scoped lock is a 
type of lock which is automatically acquired when an object is created and automatically released when the object 
is destroyed. This is an especially vital feature in multi-threaded programs.

Here is an example that shows how it works. 

```c++
#include <iostream>
#include <memory>

int main()
{
  // Create a unique pointer to an array of 10 integers
  std::unique_ptr<int[]> array(new int[10]);

  // Use the array
  array[0] = 0;
  array[1] = 1;

  std::cout << "array[0]: " << array[0] << std::endl;
  std::cout << "array[1]: " << array[1] << std::endl;

  // When the unique_ptr goes out of scope, the array is automatically deleted.
  return 0;
}
```

In the example above, we demonstrate the use of RAII in C++. It creates a `unique_ptr` which automatically manages 
an array of 10 integers. The array is used and then when the `unique_ptr` goes out of scope, the array 
is automatically deleted.

*RAII in Rust*

RAII is not limited to C++, as it is also used in other programming languages. For example, 
the Rust programming language uses RAII extensively to manage memory. Rust uses a 
type of memory ownership called `move semantics` which ensures that resources are always 
managed properly.

RAII is implemented in Rust through the use of ownership and borrowing. For more details, here is
a quick introduction below about what are ownership and borrowing concepts in Rust. 

What is Ownership?
Ownership is the concept of a value being owned as soon as it is assigned to a variable. When a variable (owner
of the value) goes out of scope, its value is automatically dropped and any associated resources are freed. 

What is Borrowing?
Borrowing is the concept of allowing a value to be borrowed by a variable from another, without transferring ownership. 
This allows the borrowed value to be used without having to worry about it being dropped while it is in use. 
Rust also provides a number of additional features, such as reference counting and garbage collection, which provides
the developer with more flexibility in dealing with memory management. 

An example of RAII in Rust is presented below with its explanation.

```rust
fn main() {
    let mut resource = Resource::new(); 
    {
        let guard = resource.lock(); // Acquire the lock 
        // Do some work with the resource
    } // Guard is dropped, lock is released
}

struct Resource {
    lock: Mutex<()>,
}

impl Resource {
    fn new() -> Self {
        Self {
            lock: Mutex::new(()),
        }
    }

    fn lock(&mut self) -> MutexGuard<()> {
        self.lock.lock().unwrap() // Acquire the lock
    }
}
```

In the above example, we show how RAII has been used to manage the resources. When the `Resource` object is created,
the lock is automatically acquired. When the `guard` object is dropped once it goes out of scope, the lock is automatically
released. This has the benefit of allowing the lock to be always held while the resource is in use and released when it 
is not needed anymore. 

*Last Words*

As a conclusion, Resource Acquisition is Initialization (RAII) is a programming technique used to manage resources in a program. 
It provides several benefits, including improved memory management, reduced code complexity, and increased reliability. 
It is used primarly in languages where there is no garbage collection, which reduces the program runtime overhead and improves
performance (in most cases!).
RAII is widely used in modern C++ programming, but it is also used in other languages such as Rust. 
As programming languages continue to evolve, RAII will remain an important concept for managing resources during the runtime
of a program. 



**Example Rust Multi-Threaded Program**

Creating threads in Rust is straightforward when using the `std::thread` module. 
This module comes standard with Rust, so no third-party codes or modules are necessary. 

An example of creating ten threads is shown here. It prints out the words "Hello", "world", "from", "a", 
"rust", "thread" and "!" in any order. The main function creates a vector of strings to output and the 
for loop iterates over these strings, spawning a new thread for each one. The join method is then called 
to wait for the thread to finish before continuing. 

This example below demonstrates the core concepts of using threads in Rust, but for more information on 
this topic, the `std::thread` module documentation can be consulted.

```rust
use std::thread; 

fn main() { 
  let sentence = vec!["Hello", "world", "from", "a", "rust", "thread", "!"];

  for word in sentence {
    let handle = thread::spawn(move || {
      println!("{word}");
    });
    
    handle.join().unwrap();
  }

  // Uncomment the line below will error out as the sentence vector has been
  // moved due to 'move keyword in closure' + 'into_iter()'
  //println!("{sentence:?}"); 
}
```

This code creates a new thread which will print out the numbers from 1 to 10, from the spawned thread. The main 
thread does the same, but prints out the numbers from 1 to 5. After the main thread is finished the spawned thread 
is joined, which waits for it to complete before continuing execution.

Here is an output of the program above.

```
Hello
world
from
a
thread
!
```

Important note about the `move` keyword is that it is used in front of a closure in Rust indicates that the closure 
takes ownership of the variables it uses in the environment. This means that the closure will move values that 
are used in the environment into the closure, and the original values will no longer be accessible after the 
closure has been called. In our case, the `Vec` is consumed and is moved into the closure and it is no more
accessible afterwards.

*Do you Find the Thread Code Above Hard to Understand?*

Rust offers a unique combination of safety and performance, with features such as static typing, memory safety, 
data race prevention, and zero-cost abstractions. This makes Rust an attractive language for those looking to 
write high-performance, reliable code. It also offers a powerful and intuitive trait-based generics system 
that can be used to create highly reusable code. 
Furthermore, Rust's powerful compiler helps developers to avoid common pitfalls and errors, while providing 
helpful error messages and suggestions. Rust's community is also very helpful and welcoming, with plenty 
of resources available to help new developers get up to speed.

Ok enough rust evangelism! and see you next time.


**What Non Deterministic Polynomial Time (NP)?**

*What is Non-Deterministic Polynomial Time?*

Non-deterministic polynomial time, often abbreviated as NP, is a class of computational problems 
used in computer science and mathematics. NP is used to describe a set of problems that can be solved
in a reasonable amount of time, but the exact solution is unknown. NP problems are considered `hard` 
because they require a large amount of resources and time to solve.

*Example of NP Problems*

One example of an NP problem is the Traveling Salesman Problem. In this problem, a salesman must visit 
several cities and find the shortest route to visit all of them. This problem can be solved by exhaustive 
search, which is a method of trying all possible routes to find the best one, but this would take a 
long time. Instead, NP problems require the use of algorithms and heuristics to quickly find good solutions.

Other examples of NP problems include the Knapsack Problem, the Hamiltonian Path Problem, and the Subset-Sum 
Problem. All of these problems are difficult to solve and require a large amount of resources and time.

*NP Problems in Computer Science*

NP problems are often used to study the limits of computation. For instance, if a problem is known to be 
NP-hard, then it is unlikely that a polynomial-time algorithm can be found to solve it. This is because 
it is believed that no polynomial-time algorithm can solve an NP-hard problem.

In addition to research, NP problems are used in practical applications. For example, they are used to 
solve the problems of scheduling, resource allocation, and network optimization.

*P vs NP Problems*

NP problems are nondeterministic polynomial time problems, which means they can be solved in polynomial 
time with a nondeterministic Turing machine. P problems, on the other hand, are deterministic polynomial 
time problems, which means they can be solved in polynomial time with a deterministic Turing machine. 
While a P problem can be solved in polynomial time, a NP problem may require exponential time to solve.

*Last Words*
Overall, NP problems are a difficult class of computational problems that can be used to study the limits 
of computation and help solve real-world problems. While these problems are difficult to solve, advances 
in computer science have allowed for more efficient algorithms and heuristics to be developed, 
which can make them easier to solve, but we are still a long way to go.


**todo articles**
https://turreta.com/2019/09/07/rust-how-to-compare-strings/
https://turreta.com/2019/09/14/rust-connect-to-mysql/


**What is 502 Bad Gateway Error?**

In this article, I will try to be as clear as possible in explaining what this error is. I've often stumbled upon this
error when browsing the internet and I have always wanted to go as deep in my understanding as possible in how the 
HTTP protocol works.


*Explaining the 502 Bad Gateway Error*

A 502 Bad Gateway error is an HTTP status code that indicates that a server received an invalid response from a 
server it was attempting to communicate with. This type of error can occur for a variety of reasons, including 
misconfigured server settings, temporary server downtime, or an overloaded server.

When a 502 Bad Gateway error occurs, it typically appears as a message on the user’s web browser. The exact 
message may vary depending on the browser, but it often reads something like `502 Bad Gateway or `502 Service Unavailable.` 


*Troubleshooting 502 Errors*

Note that the 502 error is a server-side issue and if it occurs it is the administrator of the server that needs to
look at the server logs (nginx/apache).

In case the webiste is hosted on an Nginx server, the Nginx error log should be the first place to look. This log 
is usually located in the “/var/log/nginx” directory and can be opened with a text/code editor. 
The log should provide information about any errors that have occurred.

In some cases, the issue may be resolved simply by restarting the server or making a few configuration changes.

*500 vs 502 Errors*

It is important to note that a `502 Bad Gateway` error is different from a `500 Internal Server Error`. A 500 
Internal Server Error is usually caused by a server-side issue, such as an issue with the server’s programming code 
or with the server’s configuration. On the other hand, a 502 Bad Gateway error typically indicates that 
the issue is with a server that the server is attempting to communicate with, such as content delivery networks 
or CDNs for example.

*500 vs 501 errors*

Another error code that is often confused with `502 Bad Gateway` is the `501 Not Implemented error`. A 501 Not 
Implemented error is typically caused when a website server does not support the functionality required to fulfill 
the request. This is often the result of a website not having the necessary code or programs in place to 
handle the user’s request. In comparison, a 502 Bad Gateway error is usually caused by an issue with the 
server the website is attempting to communicate with.

*502 vs 404 errors*

It is also important to distinguish a `502 Bad Gateway` error from a `404 Not Found` error. A 404 Not Found error 
indicates that the website cannot be found, often due to a broken link or a mistyped URL. In contrast, 
a 502 Bad Gateway error typically occurs when there is an issue with the server the website is attempting to communicate with.



**What is a Fat Pointer in Rust?**

Today, I will discuss what a fat pointer is in rust. This is one of the concepts that any rust developer needs to master
in order to become productive with the language. 

*What is a Fat Pointer?*

A fat pointer in Rust is a data structure that contains a pointer to a value, along with additional metadata about 
the value. This additional metadata can include information such as the length and alignment of the value, as 
well as whether the value is owned by the pointer or not. Fat pointers are often used in Rust to ensure 
safe memory access and to provide additional data about the values they point to.

*Examples of Fat Pointers*

Some examples of fat pointers include: 
- Slice type `&[T]`
- Trait object type `&dyn Trait`
- Reference cell type `&RefCell<T>`

*Size of a Fat Pointer*

The size of a fat pointer in Rust depends on the type of pointer being used. For example, a 
slice type `&[T]` is two words in size. Similarly, a trait object type `&dyn Trait` is also two words in size.

```rust
struct MyTraitImpl;

trait Trait {}

impl Trait for MyTraitImpl {}

fn main() {
    let my_slice: &[i32] = &[1, 2, 3];
    let my_trait_object: &dyn Trait = &MyTraitImpl;
 
    println!("Slice pointer size: {}", std::mem::size_of::<&[i32]>());
    println!("Trait object pointer size: {}", std::mem::size_of::<&dyn Trait>());
}
```

The output is as follows.

```
Slice pointer size: 16
Trait object pointer size: 16 
```

*Then What is a Thin Pointer in Rust?*

A thin pointer in Rust is a pointer to a value with no additional metadata. 
Thin pointers are used to store values that are not owned by the pointer, such as references to data owned by another
variable. 
Thin pointers are generally more efficient than fat pointers, since they do not need to store any additional data. 
However, they lack the safety features of fat pointers, since they do not store any information about the data they point to.

*Examples of Thin Pointers*

Examples of thin pointers include a reference type `&T` and a raw pointer type `*const T`.

```rust 
fn main() {
    let my_ref: &i32 = &42;
    let my_raw_ptr: *const i32 = &42;
 
    println!("Reference pointer size: {}", std::mem::size_of::<&i32>());
    println!("Raw pointer size: {}", std::mem::size_of::<*const i32>());
}
```

Here is below the output of the program.

```
Reference pointer size: 8
Raw pointer size: 8
```

**What Does 'let x = x;' Do in Rust?**






**How to Print Struct Fields in Console in Golang?**

*Problem*

How do I print the fields of the following struct in golang.

```go
type Project struct {
    Id      int64   `json:"project_id"`
    Title   string  `json:"title"`
    Name    string  `json:"name"`
    Data    Data    `json:"data"`
}
```

*Solution using json.MarshalIndent*

In golang, you can print the fields of a struct in the console by using `json.MarshalIndent`. This package 
is used to marshal (convert) a struct into a JSON object. This means that you will be able to display 
the fields of a struct as a JSON object in the console.

In this example, we will use the `Project` struct from the question to demonstrate how to print the fields 
of a struct in the console.

Let's first create an instance of a `Project` struct and assign it to a variable.

```go
project := Project{
    Id:   1,
    Title: "My Project",
    Name:  "Project 1",
    Data: Data{
        Type:  "text",
        Value: "My project data"
    }
}
```

Next, we will use the `json.MarshalIndent` package to convert the struct into a JSON object.

```go
b, err := json.MarshalIndent(project, "", "    ")
if err != nil {
    log.Fatalln(err)
}
```

Now, let's print the result to the console.

```go
fmt.Println(string(b))
```

Here is the output to the console when running the code.

```
{
    "project_id": 1,
    "title": "My Project",
    "name": "Project 1",
    "data": {
        "type": "text",
        "value": "My project data"
    }
}
```

And that's how you can print the fields of a struct in the console using `json.MarshalIndent`.


*Shortcomings of json.MarshalIndent*

The two main disadvantages of `json.MarshalIndent` are:
- It does not print field type and length.
- It only serializes the exported fields of a struct 

An alternative tool, such as `Spew`, may be better suited for printing field type and length.


**Is Watching Twitch Programming Streams Useful for You as an Aspiring Software Engineer?**

Short answer is yes.


*You'll Learn a Lot*

Yes, watching twitch live stream programming can be useful for aspiring software engineers. 
It can help them to learn new programming languages, get familiar with best coding practices, and understand 
different approaches to solving programming problems. Additionally, they can get tips on how to improve 
their coding skills, learn about different frameworks and technologies, and get advice from experienced developers. 
Watching twitch live stream programming can be a great way to stay up-to-date on the 
latest trends in software engineering.

Tip: Try to be active as much as possible. For instance, if the streamer talks about a subject that you 
are not familiar with, it is good practice to search for it and try to get to understand/master it.


*Realize that Developers are Humans*

Having imposter syndrome can be a major obstacle for aspiring software engineers. Watching developers 
working live on twitch can be a great way to help overcome this feeling. By seeing developers making 
mistakes, struggling to find solutions and using Google to figure things out, it can help aspiring 
engineers realize that everyone has to go through the same process to become a successful software 
engineer. It can also provide them with a valuable insight into the real-world challenges and problems 
that software engineers have to face. Watching twitch live stream programming can be a great way to 
gain confidence and help aspiring software engineers stay motivated to pursue their dreams.

*Reality vs Fiction*

The developers that you see in movies are often portrayed as being super-smart and ultra-fast. They are 
often presented as having all of the answers and never making mistakes. This is not a realistic 
representation of software developers. On the other hand, watching developers live streaming on twitch 
gives you a much more realistic look at software engineering. You can see developers struggling with
cryptic error messages, getting stuck for minutes (or hours!), and heavily using Google/documentation 
to figure things out. This can help aspiring software engineers to understand that they are not 
alone in their struggles and can provide them with valuable insight into the real-world challenges 
and problems that software engineers have to face.

The real software engineer has little to do with the hacker type that is often present in movies.


**HEAD vs OPTIONS HTTP Methods**

As a software developer, it's not enough to just create simple CRUD applications; in the real world, you must 
be able to understand and work with the entire HTTP protocol stack. 
Rather than brute-forcing my way to solutions, I prefer to take the time to comprehend complex concepts, 
which will ultimately make me faster in the long run. 

That's why in this article, I'm going to explain the distinction between the HTTP methods HEAD and OPTIONS.

HTTP methods are the verbs used to communicate with a web server, such as GET, POST, PUT, and DELETE. Two 
lesser-known methods are HEAD and OPTIONS. While these two methods are not used as often as the others, 
they are still important for understanding how the web works.

*HTTP HEAD*

The HEAD method is used to retrieve information about a resource without actually transferring the resource 
itself. This method allows the client to ask the server for certain information, such as the size of the 
resource, the type of data it contains, and the last time it was modified. 
This is useful for caching technologies, allowing the client to check if a resource has been modified 
since it was last requested.

Example HEAD request:

```
HEAD / HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9
Connection: keep-alive
```

*HTTP OPTIONS*

The OPTIONS method is used to query the server about what HTTP methods are supported for a resource. 
This allows the client to determine what operations it can perform on a resource. For example, the client 
may wish to determine whether the server supports the POST method before attempting to post data to the server.

Example OPTIONS request:

```
OPTIONS / HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9
Connection: keep-alive
```

*HEAD vs OPTIONS*

OPTIONS and Head are both HTTP request methods used to communicate between a client and a server. 

The primary difference between them is that OPTIONS is used to retrieve information about the server's capabilities, 
such as supported HTTP methods, while HEAD is used to retrieve the response header for a specific resource, 
such as the size of a file or the last time it was modified. 

In other words, OPTIONS is more generic and is used to query the server for available resources and methods while 
HEAD is used to retrieve specific information about a specific resource. 

Both methods can be used to determine if a resource is available on the server or not.



**What Does 'Allow-Access-Origin: *' Mean?**

Access-Control-Allow-Origin: * is an HTTP header that tells web browsers that the content of 
a web page can be accessed by any other domain. 
This allows webpages to be shared across different websites, making it easier to share resources 
such as images, videos, and other data.

A popular website, `imgur.com` uses that header to make it possible to share images easily. 

Here is an example of a response with it. 

```
Access-Control-Allow-Origin: *
Content-Type: application/json; charset=utf-8
...
{
  "data": "content"
}
```

**Principles of Software Design**

Software Design is an exciting process of transforming software requirements into an action 
plan to create an amazing software system. To make sure we get the best out of this process, 
there are certain principles that we need to use in the design of the software. 
These principles are key in making sure the software is working properly, is reliable and user-friendly. 
By keeping these principles in mind, we can create an excellent software system that everyone can use with ease.

*Avoid Tunnel Vision* 
When designing software, it is important to avoid tunnel vision and remain open to the possibility 
of different solutions. It is important to remain aware of the wider context and consider other 
approaches and perspectives that may be more suitable for the project. It is also important 
to take into consideration the user experience and the implications of the design decisions made.

*Maintain Tracability up to Analysis Model* 
It is important that the design of software is traceable to an analysis model. This is important 
to ensure that the software is designed to meet the requirements and the needs of the user. Furthermore, 
it is important to ensure that the design is flexible enough to accommodate changes that may arise over time.

*Avoid Reinventing the Wheel* 
When creating software, it is important to avoid reinventing the wheel. It is important to use 
existing, proven technologies and frameworks that have already been developed. This will help 
to streamline the development process, reduce errors, and save time and money.

*Shortening Intellectual Distance* 
It is important to minimize the intellectual distance between the design, development, and testing 
stages of a software project. This is important to ensure that the software is designed to meet the 
requirements and the needs of the user. It is also important to ensure that the software is designed 
to be maintainable and extensible.

*Maintain Uniformity and Integration*
When designing software, it is important to ensure that the design exhibits uniformity 
and integration. This is important to ensure that the design is consistent and efficient. 
It is also important to ensure that the software is designed to be extensible and maintainable.

*Make Change Possible* 
It is important to ensure that the design of the software is able to accommodate any changes 
that may arise over time. This is important to ensure that the software is able to remain up 
to date with the latest technology and trends. It is also important to ensure that the 
design is flexible enough to accommodate changes that may arise over time.

*Degrade Progressively* 
It is important to ensure that the design of the software degrades gracefully. This 
is important to ensure that the user experience is not impacted by any changes or 
upgrades that may occur over time. It is also important to ensure that the software 
is designed to be easy to upgrade and maintain.

*Assessed for Quality*
It is important to ensure that the software is assessed for quality before it is released. 
This is important to ensure that the software meets the requirements and the needs of the user. 
It is also important to ensure that the software is reliable and secure.

*Review to Discover Errors*
You should review your software project to discover any errors or bugs before it is released. 
This is important to ensure that the software is reliable and secure. It is also important 
to do so before it is released.

*Design and Coding are Two Separate Animals*
Design is different from coding or programming. 
Design is the process of conceptualizing, planning, and developing a software product. Coding 
is the process of writing code to implement the design. It is important to ensure that the 
software is designed to meet the requirements and the needs of the user.




**How to Acheive Your Goals and Dreams**

I strongly believe that everyone should be free to follow their dreams without fear of judgement 
or criticism from others. No one should ever be made to feel like they are not allowed to strive 
for something they want. Everyone should be given an opportunity to explore their passions and 
work towards their goals in a safe and supportive environment. 

*Realize Your Dreams*

Everyone needs to have a purpose in life to keep going. And being able to realize your dreams is maybe one the 
most empowering experience that is. This brings meaning to an apparently meaniningless existence.  
To get started, take the time to write down your goals and create a plan of action. Break them down into 
smaller, more achievable steps, and then take action. Don't be afraid to ask for help from 
friends, family and mentors. Celebrate your progress along the way and reward yourself for your 
hard work. 

There is no impossible task. No matter how difficult the task may seem, if you remain focused and motivated, 
you can make your dreams come true. When you believe in yourself, you are able to set realistic goals and 
work hard to reach them. It is important to stay positive, even when you face challenges. 
A positive attitude will help you stay motivated and remain focused on your objectives.

Only hard work, consistency and dedication can help you acheive success. Start by setting small goals and 
working your way up to larger ones. Make sure to take the time to develop your skills and knowledge. 
With a little bit of effort, even the most seemingly impossible tasks can be achieved.

Last but not least, believe in yourself! That may sound cliche but it is key to making your dreams a 
reality. Set realistic goals and work hard to reach them. Stay positive, and don’t let setbacks 
stop you from achieving what you want. Surround yourself with supportive people and take the time 
to develop your skills and knowledge. Allow yourself to be a little bit egocentric and egoistic.


*Beat Obstacles*

In the following, here are some practical advices about how to beat obstacles that might get in your way
to acheiving your goals.

Overcoming obstacles can seem daunting, but with the right approach, you can achieve your goals. Start 
by identifying the obstacle and understanding why it is preventing you from reaching your goals. 
Then, create a plan of attack that includes both short-term and long-term goals.

To remain motivated and focused on the task at hand, remind yourself of the end goal and why it is 
important to you. The more meaningful the goal (hint: not money alone!), the more you will have that 
burning desire to keep going every single day. 
Celebrate small successes and enlist a support system to help keep you accountable. Be open to 
new ideas and adjust your plan as needed.

It is also important to take care of yourself, always remember that we are not machines. Achieving 
goals can be stressful, so make sure to take breaks and take care of your mental and physical 
well-being. For my part, practicing daily sport activities have a tremendous effect on my overall 
health. Walking on the beach is also something I try to do at least one a week. 

With these strategies, you can overcome (almost) any obstacle and achieve your goals.

*Get Going Now*

Here is how I would do it if I were you.
I have always had a dream of becoming a successful person and making a positive impact in my community. 
To achieve this, I have been diligently working to acquire the necessary skills to find a meaningful job
where my contribution is positive to the company and the community as a whole. I am also staying up 
to date on industry trends and connecting with like-minded individuals. 
Each day I am motivated to take small steps to move closer to my goal. By putting in hard work and 
dedication, I am confident that I will be able to make my dream a reality.

*Quick Tips*

I suggest jotting them down and keeping them in your work space so they serve as a daily reminder.

1. Believe in yourself and your dreams
2. Set achievable goals
3. Network and connect with people who share the same interests and goals
4. Take risks and be willing to fail
5. Persevere and never give up

*Open Source Personal Experience*

Mental toughness is a must and consistency is vital if you want to achieve your goals. As a 
contributor to open source software, you will come across a lot of hostile and unhelpful people 
who will not hesitate to criticize you when you make a mistake. Therefore, choose your projects 
wisely and don't accept such behavior as the norm. When you encounter it, decide if you want to 
abandon the project or look for another maintainer to work with.


**What is Function.prototype.length in JavaScript?**

Today, I was inspecting a function's property names and stumbled upon the following result.

```
['name', 'length']
```

And I wondered for a while what the `length` property is. Here is the explanation below.


`Function.prototype.length` is a property of the Function prototype object that specifies 
the number of arguments expected by the function.

Here is an example that you can run in your browser's console, for instance.

```javascript
const foo = (x, y, z) => {
  console.log(x, y, z);
}; 

console.log(foo.length); // 3
```


**How to Split a String using Regex in JavaScript**

You can use the JavaScript `String.prototype.split()` method to split a string by a regular expression. 
You will need to use a regex that you pass to the method.

In order to use the the JavaScript `split()` method, provide the regular expression as the only parameter. 
The forward slashes `/ /` mark the beginning and end of the regular expression. 
The return value of the split method is an array of each substring that matches the regular expression.

*Example of Using Regex to Split a String*

Here is an example of its usage.

```javascript
const input = "a.b cd,efgh";
const result = input.split(/[\s.,]/);

console.log(result);
```

The example shows how the string, `a.b cd,efgh`, is stored in the variable `input`. The `split()` method is 
called on the string and passed the regular expression `/[\s.,]/` as a parameter. 
This regular expression matches the spaces, periods or commas in the string. 

Here is the output of the program where the method returns an array of substrings based on 
each match of the regular expression. 

```
['a', 'b', 'cd', 'efgh']
```

*Example of Using Regex to Split a String on Vowels* 

For example, if you want to split a string on each vowel, you can use the `/[aeiou]/` regex item. 
This will match any vowel character in the string and split it into separate words.

Here is an example of its usage.

```javascript
const input = "vacEdfikjOxz";
const result = input.split(/[aeiou]/);

console.log(result);
```

The output is as follows.

```
['v', 'cEdf', 'kjOxz']
```

You can also use character flags when splitting strings. 
For example, using the i flag will match uppercase and lowercase occurrences of the characters 
in the class.

```javascript
const input = "vacEdfikjOxz";
const result = input.split(/[aeiou]/i);

console.log(result);
```

The output is as follows as it takes into account both the lower and upper case characters.

```
['v', 'c', 'df', 'kj', 'xz']
```




**How to Copy All the Contents of a Directory in a New Directory?**

Copying the contents of one directory to another in Linux (Ubuntu) is a fairly simple task that 
can be accomplished in several ways. I will show one way in this article in order to
not confuse you! 

We will use the `cp` command to copy all of the files in a directory to a new directory.

To begin, open a terminal window and navigate to the directory that contains the files 
you want to copy. 

For example, if the files are located in `~/Documents/old_directory`, you would enter the following command:

```bash
cd ~/Documents/old_directory
```

Once you are in the correct directory, you can use the `cp` command to copy all of the files in 
the directory to the new location. 

To do this, use the following command:

```
cp -r * ~/Documents/new_directory
```

This command will copy all of the files in the old directory to the new directory. 

*What is the '-r' Flag?*

The `-r` flag tells the `cp` command to copy all of the files in the directory recursively, 
meaning it will also copy any subdirectories and their contents.


*Verify that 'cp' Worked*

Once the command has run, you can verify that the files have been copied successfully by navigating 
to the new directory and running the `ls` command. 
If the files have been copied successfully, you should see a list of the copied files and folders.

```bash
ls ~/Documents/new_directory
```


That's all there is to it! The cp command is a powerful tool for copying files and directories 
in Linux, and it's a great way to quickly move files from one directory to another.

*How About Moving Content to New Directory?*

If we wanted just to move the content in the folder we can do it by using `mv` command.

```bash
mv ~/Documents/old_directory/* ~/Documents/new_directory/
```

**How to Autoformat JavaScript Code with Deno** 

*What is Deno?*

Deno is a modern JavaScript runtime that allows you to execute JavaScript code on the server 
side. It comes with a built-in formatter that makes it easy to autoformat JavaScript code. 

*What is Deno Formatter?*

The Deno formatter uses the same code formatting rules as the popular Prettier library.

*How to Use Deno Formatter?*

Using the Deno formatter is very simple. First, you need to install Deno on your machine. 
Once you have done that you can run the following command to autoformat your JavaScript code:

```bash
deno fmt <file_name.js>
```

This command will read the file specified and format it according to the Prettier rules. It can 
be used on a single file or multiple files at once. The command can also be used to reformat 
an entire directory of files by using the -r flag. For example:

```bash
deno fmt -r <directory_name>
```

This command will reformat all the JavaScript files in the specified directory.


*Last Words*

The Deno formatter is a great tool for keeping your JavaScript code neat and consistent. It is 
quick and easy to use, and it helps to ensure that your code is properly formatted and free of errors.


**Golang scanner Package**

In this tutorial, I'll introduce you to the `scanner` package in Golang, explain what tokenization 
is, provide an example of tokenizing Python source code, and show you an example program that 
demonstrates how to tokenize golang source code using the package.

*What is Golang scanner Package?*

The scanner package in golang is used to read data from various sources and convert it into tokens. It can also be used to parse formatted input, such as text or binary data, into individual tokens.


*What are Some of the Functions of the scanner Package?*

The `scanner` package in Golang provides several methods for parsing and tokenizing data. These include 
the `Scan()`, `ScanBytes()`, `ScanRunes()`, `ScanLines()`, and `ScanSlice()` methods. The `Scan()` 
method reads data from a given source and returns the next token found. `ScanBytes()` reads a single 
token from the source and `ScanRunes()` reads a single token and returns it as a rune. Whereas, 
`ScanLines()` reads input as lines, and `ScanSlice()` reads a slice of data from the source.


*What Does Tokenization Means?*

Tokenization is the process of breaking down a large data set into smaller, more manageable pieces 
called tokens. It is widely used in Natural Language Processing (NLP) and Machine Learning applications 
for separating words, phrases, numbers, and other elements that can then be analyzed or used to 
create new datasets. 
Tokenization is a useful tool for making data more manageable and easier to process.


Here is an example of tokenization of a Python source code (main program):
```
[Keyword, 'def'], [Identifier, 'main'], [Punctuation, '('], [Identifier, 'argv'], [Punctuation, ')'], [Punctuation, ':'], [Keyword, 'print'], [Punctuation, '('], [String, '"Hello World!"'], [Punctuation, ')'], [Punctuation, ']'
```

This tokenization example is showing the breakdown of a Python source code main program. The tokens 
are indicating the type of element within the code, such as a keyword (def) or an identifier (main). 
The punctuation marks (() :) are also used to separate elements. 
Finally, the string "Hello World!" is also present.

*Using the scanner Package*

We will be utilizing the `scanner` package in order to tokenize each line of a tiny Golang program source 
code that is being passed to it using the `scanner.Scan()` method which yields the `position`, `token`, 
and `literal` for each token encountered.

```go
package main

import (
	"fmt"
	"go/scanner"
	"go/token"
	"strings"
)

func main() {
	src := []byte("package main\nimport (\n\t\"fmt\"\n)\nfunc main() {\n\tfmt.Println(\"Hello world!\")\n}")
	var s scanner.Scanner
	fset := token.NewFileSet()
	file := fset.AddFile("", fset.Base(), len(src))
	s.Init(file, src, nil, scanner.ScanComments)
	
  for {
		pos, tok, lit := s.Scan()
		if tok == token.EOF {
			fmt.Println("end of file!")
			break
		} else if strings.Contains(lit, "\n") {
			fmt.Printf("%s - end of line\n", fset.Position(pos))
		}
	}
}
```

The code above uses the `scanner` package to tokenize source code from a byte array. It then checks 
if a token is end of file (EOF) and if so, prints "end of file". It also checks if the token is 
a line ending, and if so, prints "end of line". It also prints the position of the token 
in the source code.


**How to Learn Programming in Go**
https://golangdocs.com/learning-golang-with-no-programming-experience

In this article, we will see how you can learn the go programming language, even for 
someone that has no prior programming experience.

*What is Go/Golang?* 
Go is an open source programming language created by Google in 2009. It is a statically typed 
language that supports multiple paradigms and is cross-platform. It is used for developing 
web applications, distributed systems, and mobile applications, as well as for large, complex 
projects due to its concurrency support. 
It is easy to learn and use, and it can compile and run quickly, making it an efficient and 
reliable language for software development.

Go is also used to build Docker and Kubernetes, two popular and powerful container orchestration 
tools. 

*Benefits of Learning Go* 
Learning Go is an advantageous skill for developers, as it is a powerful, efficient language 
that can be used to build complex applications. Lots of fortune 500 companies such as Google, 
Dropbox, and Uber use Go in their projects, and its popularity with developers is increasing 
due to its ease of use and compiled language, which allows for faster program execution. 
Knowing Golang can open up many doors, from working on projects for major companies to launching 
one's own products.

Here is a summary of the benefits of learning Go:

• Easy to learn and use 
• Compiled language for faster program execution 
• Popular among major tech companies 
• Supportive tools and libraries 
• Opportunities for career advancement and product development


*What is Needed to Learn Go?*

In order to learn Go, developers should have a basic understanding of programming concepts 
such as syntax, variables, flow control, and loops. Additionally, knowledge of networking, 
web programming, data structures, algorithms, concurrency, and parallelism can be very beneficial 
for building complex applications in Go. Having a good understanding of these topics will enable 
developers to write efficient and effective code in Go, and open up many opportunities for career 
growth and product development.

Here is what is needed to learn in order to master, or at least become job ready in Go.

• Basic programming concepts (Syntax, Variables, Flow Control, Loops) 
• Networking 
• Web Programming 
• Data Structures & Algorithms 
• Concurrency & Parallelism

*Start with the Fundamentals*

Learning the fundamentals of Go can be accomplished by setting up an environment, familiarizing 
yourself with the syntax and variables, and practicing with writing and debugging code. The best 
way to get started is to set up your environment, which includes downloading the Go compiler from
the official go website, at the url`go.dev/dl`, setting up your workspace, and learning the basics 
of the language. 

Now, that your environment is set up, you are ready to go. You can start by learning the syntax and 
variables, such as data types, operators, and functions.
One recommendation is to practice simple problems using the website `Go Tour`.
The Go Tour website (`https://tour.golang.org`) is an interactive tutorial for learning Go, with 
each module explaining a different concept and providing exercises. In my opinion, this is the 
best beginner resource out there. It gets you up and running in no time. 

Finally, you can practice writing and debugging code by creating your own Go programs, such as 
CLI utilities and web services, and using the tools and libraries available to you.
Some of the libraries that you should be aware of are Cobra, Gin Framework and GORM. There is
also the powerful package `GoGi` and `GoKi` which allows you to build advanced 2D and 3D interfaces. 

By following these steps, you will be able to learn the fundamentals of Go and begin building real
word applications quickly and efficiently. 

*Make the Best Use of Online Tutorials*

Checking tutorials and available documentation are the best ways to learn Golang. 
The language has the benefit of a large and active community. You'll find dozens of questions with 
their answers in stackoverflow and the golang forum. 
Also, there are plenty of tutorials and documentation available online to help you get started with 
Golang and become a proficient user. 
One of the main benefits of tutorials is that they will help you understand the syntax and basics of 
the language and the documentation will provide you with deeper knowledge of the language and its 
features. So first, start with tutorials and then move to the documentation. 
Additionally, you can find resources and references to help you with more advanced topics. 
In order to dig even deeper, you can start reading the source code of some popular opensource projects
written in Golang. 

Here is an non-exhaustive list of tutorials with a description for each.

Golang Tour from `golang.org`: This tutorial walks you through the basics of the Go 
language, from declaring variables to working with types and functions. It also 
covers more advanced topics such as concurrency and package management.

Go By Example: This tutorial provides a comprehensive introduction to the Golang language. 
It covers the basics of the language, such as variables, types, and functions, as well as 
more advanced topics such as concurrency, packages, and error handling.

Golang Programming Language Tutorials from DigitalOcean: This series of tutorials covers the 
fundamentals of the Golang language, including variables, loops, functions, and error handling. 
It also covers topics such as object-oriented programming, concurrency, and network programming.

And of course, this very same website.

*Last Words*

Go is a great choice for developers of all levels. It is user-friendly and provides a number of 
benefits, such as efficient functioning, concurrency, and speed. 
With its relatively short learning curve, Go can be integrated with other coding languages, frameworks, 
libraries, and databases. All in all, the Go language is a great tool for software and web development.


*How long does it take to learn Go basics?* 
It typically takes around 2-3 weeks to learn the basics of Go programming language.

*Is Go a popular language among recruiters?*
Yes, Go is becoming increasingly popular among recruiters as it is a powerful language 
that is easy to learn and use.

*Is Go a compiled or interpreted language?* 
Go is a compiled language.

*What is the difference between Go and other programming languages?* 
Go is a statically-typed language with a focus on simplicity and concurrency. It has 
a unique syntax that is different from other programming languages, such as C, Java, and Python.

*What are the benefits of using Go?* 
Go is a powerful and easy to learn language that is well suited for building powerful and scalable 
applications. It provides strong static typing, high performance, and concurrency support.

*What are the commonly used packages in Go?* 
The most commonly used packages in Go include the standard library, database drivers, web 
frameworks, and network libraries.

*How can I get started with Go?* 
You can start with the Go language documentation and tutorials to get familiar with the language 
basics. You can also learn by building small projects and solving coding challenges.

*What are the tools used for developing Go applications?* 
Go comes with a set of useful development tools that help with writing, testing, and 
debugging code. These tools include the Go command-line tools (go, gofmt, and goimports), 
the Go compiler (gc), and the Go debugger (gdb).

*What are the best practices for writing Go code?*
When writing Go code, it is important to keep your code simple, use good naming conventions, and 
use error handling and logging appropriately. Additionally, it is important to test your code 
and use static analysis tools to verify the correctness of your code.

*How can I debug my Go code?* 
Go comes with a built-in debugger, gdb, which allows you to step through your code line by line 
and inspect variables. Additionally, there are several third-party tools that can be used to debug 
Go code.

*What are the most popular Go frameworks?* 
The most popular Go frameworks include Gin, Echo, and Revel. These frameworks provide features such 
as routing, middleware, and templating, which make it easier to develop web applications.






**How to Maximize Go Program's Performance**
https://golangdocs.com/techniques-to-maximize-your-go-applications-performance

Go is an open-source programming language designed for efficient and reliable software development. It is a powerful language that makes it easy to create high-performance applications. However, in order to maximize the performance of a Go application, developers must take the time to properly analyze and optimize their code. This article will discuss some of the techniques that can be used to maximize the performance of a Go application. We will cover topics such as analyzing the architecture of an application, utilizing Go’s built-in features, monitoring the application with profiling and tracing, and employing code optimization techniques. By following these techniques, developers will be able to make their applications run more efficiently and achieve superior performance.


1. Analyze your application’s architecture: Identify bottlenecks of your application, then break them down and look for ways to improve their performance. 
Analyzing your application's architecture is essential in order to maximize its performance. By breaking down the application's bottlenecks and analyzing them, you can identify areas of improvement and optimize them accordingly. For example, if a certain component of the application is taking longer to run than it should, it could be due to inefficient code or an inefficient algorithm. By looking into the underlying code and making changes, it may be possible to improve the performance of that component. Similarly, if a certain database query is slow, you can look into the query and make changes to speed up the query's execution. By properly analyzing the architecture of your application, you can identify and fix bottlenecks which will improve the performance of your application.

2. Utilize caching: Caching can help reduce the need to query the same data from the database multiple times, resulting in improved performance. 
Caching can be a great way to maximize the performance of a Go application. It can help reduce the amount of time spent querying the same data from the database multiple times, resulting in improved performance. Caching involves storing data temporarily in memory so that it can be accessed quickly. For example, you can store items that are frequently used by the application, such as user profiles or product listings, in a cache so that they can be accessed quickly when needed. You can also set up a caching system that automatically refreshes the data periodically to ensure that the most up-to-date information is available. Utilizing caching can reduce the load on the database and improve the performance of the application overall.

3. Optimize your code: Take the time to go through your code and look for areas that can be optimized for better performance. 
Optimizing the code of your Go application is a key step in maximizing its performance. By taking the time to go through your code and identifying areas where it can be improved, you can boost the performance of your application. For instance, you can use the “go fmt” tool to format your code in the most efficient way or use the “go vet” tool to check for potential bugs and errors. Additionally, using libraries such as “go-micro” can help you avoid writing your own code for common operations. Finally, you can use the profiling tools such as “pprof” to identify and remove bottlenecks that are causing the application to run slowly. By taking the time to optimize your code, you can significantly improve the performance of your Go application.

4. Utilize concurrency: Concurrency can help you take advantage of multiple cores on the same machine, resulting in faster processing. 
Utilizing concurrency can be an effective way to maximize the performance of your Go application. By utilizing concurrency, you can take advantage of multiple cores on the same machine, resulting in faster processing. This can be done through the use of go routines, channels and other concurrency primitives. For example, you could use go routines to execute multiple tasks in parallel, or use channels to communicate between different parts of the application. This can help you make the most of the resources available, allowing your application to run more efficiently.

5. Utilize Go’s built-in features: Go has a number of features that can help you improve performance, such as garbage collection. 
Go’s built-in features can be a great way to maximize your application’s performance. For example, garbage collection can help manage memory by freeing up any unnecessary memory as soon as it is no longer needed. This can help improve performance as the application no longer has to store or manage unnecessary data. Additionally, Go’s concurrency features can be used to improve performance by allowing multiple tasks to be performed simultaneously, allowing for faster execution of code. Finally, Go’s built-in profiling tools can allow you to identify any potential performance issues, allowing you to further optimize the code and make sure that the application is running at its best. By utilizing the built-in features of Go, you can ensure that your application is running at its peak performance.


6. Monitor your application: Use tools such as profiling and tracing to monitor your application and identify areas that need improvement. 
Monitoring your Go application is an essential step to maximizing its performance. By using profiling and tracing tools, developers can measure and identify performance bottlenecks. Profiling tools such as pprof and go-torch can provide data on execution times, memory usage, and locks, while tracing tools such as OpenTracing and Zipkin can collect detailed information about the application’s internal and external interactions. Having this information can help developers identify areas of the application that may need improvement to achieve better performance. For example, if a certain function is taking too long to execute, a developer can optimize the code to speed up the process. Similarly, if an application is utilizing too much memory, a developer can opt to use a cache to reduce the memory usage.

7. Use an efficient database: Choose a database that is optimized for your application’s needs and provides the best performance. 
Using an efficient database is essential to maximize the performance of a Go application. An optimized database should be chosen based on the application's needs, with consideration given to the type of data, storage requirements, and query requirements. Popular databases such as MySQL, MongoDB, and PostgreSQL are all excellent options. Additionally, using a cloud-based database service such as Amazon RDS or Google Cloud SQL can help to improve performance, reduce costs and improve reliability. By selecting the right database, performance can be improved and scalability can be achieved.

*Last Words*

In conclusion, there are many techniques that can be used to maximize the performance of a 
Go application. By analyzing the architecture, utilizing caching, optimizing code, taking 
advantage of Go’s built-in features, monitoring the application, and employing code 
optimization techniques, developers can ensure that their Go applications are running at their best.


**How to Convert a Byte Array to a String**
https://golangdocs.com/golang-byte-array-to-string

Byte arrays are widely used data structures in GoLang. They are essentially lists of bytes and 
can be used to store large amounts of data. Byte arrays are particularly useful for storing 
binary data such as images, audio, and other multimedia content. 

In today's article, we will show how to convert a byte array to a string, using three different methods
including the `string` function, the `copy` function as well as the `fmt.Sprintf` function. 


*Using the String Function*

The `string` function is the most straightforward way to convert a byte array to a string in GoLang. 
This function takes a byte array and returns a string representation of the array. 

For example, if we have a byte array called `byteArray`, we can use the `string` function to convert 
it to a string by calling:

```go
package main

import (
	"fmt"
)

func main() {
	byteArray := []byte{'h', 'e', 'l', 'l', 'o'}

	stringResult := string(byteArray)
	fmt.Println(stringResult)
}
```

*Using the Copy Function*

The `copy()` function is another way to convert a byte array to a string. This function takes a 
destination and a source, and copies the contents of the source into the destination. 

Here is an example of how to do the conversion. If we have a byte array called `byteArray` and 
a string called `stringResult`, we can use the `copy` function to convert the byte array to a 
string as follows. 

```go
package main

import (
	"fmt"
)

func main() {
	byteArray := []byte{'h', 'e', 'l', 'l', 'o'}

	stringResult := make([]byte, len(byteArray))
	copy(stringResult, byteArray)
	fmt.Println(string(stringResult))
}
```

*Using fmt.Sprintf*

The `fmt.Sprintf` function is the third way to convert a byte array to a string. This function 
takes a format string and a list of arguments, and returns a string representation of the arguments. 

Now, let's show how it works using the example program below where we convert the byte array `byteArray`
using `Sprintf` function to convert it to a string.

```go
package main

import (
	"fmt"
)

func main() {
	byteArray := []byte{'h', 'e', 'l', 'l', 'o'}

	stringResult := fmt.Sprintf("%s", byteArray)
	fmt.Println(stringResult)
}
```

*Last Words* 
Tere are three main ways to convert a byte array to a string in GoLang. All three methods are 
relatively straightforward and can be used to quickly convert a byte array to a string. 
The benefits of converting a byte array to a string are that it allows for easier manipulation 
and storage of binary data.

**Golang JSON**
https://golangdocs.com/json-with-golang


*Marshaling and Unmarshalling in Golang*

Marshaling is the process of encoding data into JSON format. This can be done in Go using the 
`Marshal()` function from the json package. An example of marshaling would be taking a struct, 
like a `Car` object, with Make and Model fields and encoding it into a JSON string.

```go
package main

import (
    "fmt"
    "encoding/json"
)
 
type Car struct {
    Make string
    Model string
}
 
func main() {
    carString := `{"Make": "Ford", "Model": "Mustang"}`
     
    var car Car
     
    err := json.Unmarshal([]byte(carString), &car)
     
    if err != nil {
        fmt.Println(err)
    }
     
    fmt.Printf("%+v\n", car)     // {Make:Ford Model:Mustang}  
}
```

Unmarshaling is the opposite of marshaling and it involves decoding a JSON string into a Go type
using the `Unmarshal()` function. 
An example of unmarshaling would be taking a JSON string, like a `Person` object with Name and 
Age fields, and decoding it into a Go object.

```go
package main

import (
	"fmt"
	"encoding/json"
)

type Person struct {
	Name string
	Age int
}

func main() {
	personString := `{"Name": "John Doe", "Age": 30}`

	var person Person

	err := json.Unmarshal([]byte(personString), &person)

	if err != nil {
		fmt.Println(err)
	}

	fmt.Printf("%+v\n", person)  // {Name:John Doe Age:30}
}
```

*How to Encode a Slice to JSON in Golang*

To convert a slice to JSON in Golang, you can use the `json.Marshal()` function. This function takes 
in an `interface{}` and returns a byte array and error.

Example:

```go
package main

import (
	"encoding/json"
	"fmt"
)

type Fruit struct {
  Name string
}

func main() {
	// Create a slice
	fruits := []Fruit{
    {Name: "Apple"}, 
    {Name: "Orange"},
	  {Name: "Banana"}
  }
	// Convert the slice to JSON
	jsonData, err := json.Marshal(fruits)
	
  if err != nil {
		fmt.Println(err)
		return
	}
	
	// Print out the JSON
	fmt.Println(string(jsonData))
}
```

Here is the output.
```
[{"Name":"Apple"},{"Name":"Orange"},{"Name":"Banana"}]
```

*How to Decode a JSON Array to a Slice of Structs*

To decode a JSON array to a slice of structs in Golang, you can use the `json.Unmarshal()` 
function. This function takes in a byte array and an `interface{}`, and returns an error.

Here is how it is done.

```go
package main

import (
	"encoding/json"
	"fmt"
)

type Fruit struct {
  Name string
}

func main() {
	// Create a JSON array
	jsonData := []byte(`[{"Name":"Apple"},{"Name":"Orange"},{"Name":"Banana"}]`)
	
	// Create a slice
	var fruits []Fruit
	
	// Decode the JSON array to the slice
	err := json.Unmarshal(jsonData, &fruits)
	
  if err != nil {
		fmt.Println(err)
		return
	}
	
	// Print out the slice
	fmt.Println(fruits)
}
```

Here is the output which is a slice of `Fruit` structs.
```
[{Name:Apple} {Name:Orange} {Name:Banana}]
```

*How to Set Custom Attribute Names in JSON with Golang*

To set custom attributes in a JSON with Golang structs, you need to use tags on the struct fields. 
Tags are defined in the struct as strings and can be used to specify the JSON field name, 
as well as any other custom options. 

Here is an example of usage of tags to set custom names.

```go
type Foo struct {
    Name string `json:"my_custom_name"`
    Total int    `json:"custom_total_count"`
}
```

In the example struct definition above, the field `Name` will be mapped to the JSON field `my_custom_name`,
and the struct field `Total` will be mapped to the JSON field `custom_total_count`.


*How to Skip Fields in JSON*

In Go, you can encode struct fields to JSON using the `"-"` character in the struct tag. 
This will tell the JSON encoder to skip that field.

Here is an example struct that skip the `Age` field in json encoding and decoding.

```go
type MyStruct struct {
  Name string `json:"name"`
  Age int `json:"-"`
}
```

*How to Omit Empty Fields in JSON*

It is possible to skip empty struct fields in json marshalling by using the `omitempty` tag. 

Here is an example struct below. 

```go
type User struct {
	Name string `json:"name,omitempty"`
	Age int `json:"age,omitempty"`
}
```

In this example, if the `Name` and `Age` fields are empty, they will not be included in the 
json output.


*How to Decode/Encode Unstructured Data*


**Golang Println() Function**

*What is the Golang Println() Function?*

The Golang `Println()` function is a versatile and useful tool for printing various type values 
in the Go programming language. It is a part of the `fmt` package and is used to display text and 
other type values on the terminal or console window. 

*Println() Syntax*

The syntax for the Golang Println() function is as follows:

```golang
fmt.Println(<var1>, <var2>, ...)
```

The `Println()` function accepts an unlimited number of type values as parameters. 
The type values can be strings, integer values, floats, booleans, pointers, and so on. 
The type values are separated by commas and can be any type that is supported by Go.

*How to Print Various Type Values with Println()*

The Println() function is used to print various type values. Here are some examples of how to print different type values with Println():

```go
package main

import "fmt"

func main() {
  //Print strings
  fmt.Println("Hello World")

  //Print integer values
  fmt.Println(10)

  //Print float values
  fmt.Println(3.14)

  //Print booleans
  fmt.Println(true)

  //Print pointers
  fmt.Println(&x)
}
```

Here is the output of the program. Note that the last pointer value will vary in each execution.

```
Hello World
10
3.14
true
0xc0000181a0
```

*Println() vs Other Print Functions*

The `Println()` function is a part of the `fmt` package and is the most commonly used print 
function. However, there are other print functions available in the fmt package. For 
example, the `Printf()` function is used to format and print strings according to a format 
specifier. The `Sprintf()` function is used to format and return a string according to a 
format specifier.

*Does Println() Insert Whitespaces Between Variables?*

Yes, the `Println()` function automatically inserts a whitespace between each type value that is 
passed to it as a parameter. 

Here is, in the following, an example of how it works.

```golang
package main

import "fmt"

func main() {
  fmt.Println("Hello", "World")
}
```

The output of the above code includes a space between the words `Hello` and `World`. 

```
Hello World
```

*Difference Println vs Printf vs Sprintf*

The main difference between Println(), Printf(), and Sprintf() is that Println() prints the type values to the terminal or console window, Printf() formats and prints the type values to the terminal or console window, and Sprintf() formats and returns a string.

*Is Println() Recommended for Debugging?*
The Println() function in Golang is a useful tool for debugging. It allows you to print various types 
of values to the console in order to inspect the output of a program or a specific statement. This can help
quickly identify errors or issues in your program. 

But for more complex programs, I recommend using a debugger such as dbg to step through your code line 
by line and analyze what is happening. In order to make the best use of the debugger, you will need 
to set breakpoints to pause execution and then inspect the values of the different variables of
the program at that step of execution. Also, in case you are trying to identify performance bottlenecks 
a profiler is then recommended.

*Last Words*
The Golang `Println()` function is a simple and easy to use way that can be used to print various type 
values to the terminal or console window. It is part of the `fmt` package and is often used as a first
resort when debugging programs.

**Structs in Golang**
https://golangdocs.com/structs-in-golang

**Const Keyword in Golang**
https://golangdocs.com/constants-in-golang-const-keyword

**How to Sort an Arrays of Numbers the Right Way in JavaScript?**

You can use the `Array.prototype.sort()` function to sort an array of numbers in JavaScript, 
however the sort function casts everything to a string so you end up with a sorted list that 
doesn't make sense. 

```javascript
[200, 30, 10].sort();  // [10, 200, 30]
```

To fix this, you can use your own sort function. For example, if you want to sort the array 
`[200, 30, 10]`, you can write a sort function that casts all the items to numbers like this: 

```javascript
[200, 30, 10].sort((a, b) => Number(a) - Number(b)) // [10, 30, 200] 
```

Which will give you the right sorted array `[10, 30, 200]`.


**Bash Shell Confusion**

*Short Answer*

The main difference between `Bash` and `Shell` is that Bash is a type of shell, while Shell is 
the generic term for a user interface to access an operating system’s services. Bash is the 
default shell for Linux and Mac OS X, while Windows has its own shell called the Windows Command Prompt,
and/or PowerShell.

*Long Answer*

The terms `bash` and `shell` are often used interchangeably, but they are not the same thing. Bash 
is a type of shell, while Shell is actually the generic term for a user interface to access an operating 
system’s services. So when someone is talking about a “shell”, they could be referring to any type 
of shell, such as `Bash`, `csh`, or `ksh`.

Bash stands for `Bourne Again Shell`, and is the default user interface for Linux and Mac OS X. It is 
a command-line interface, meaning that users enter commands in text form to perform specific tasks. 
Bash is based on the original Bourne Shell, and is designed to be compatible with the Bourne Shell 
syntax. It also includes many features from other shells, such as csh, ksh, and tcsh.

Shells are not just used in Linux and Mac OS X. Windows has its own shell, called the Windows Command 
Prompt. The command-line interface of the Windows Command Prompt is different than the Bash shell, 
but it still allows users to enter commands to perform various tasks.

So to summarize, Bash is a type of shell, while Shell is the generic term for a user interface to access 
an operating system’s services. Bash is the default shell for Linux and Mac OS X, while Windows has 
its own shell called the Windows Command Prompt.

*Example Shells*

`Bash (Bourne Again Shell)`: Bash is the default shell in many Unix-based operating systems, including 
Linux and macOS. It is a command-line interpreter that is designed to be compatible with the original 
Bourne Shell syntax. Bash has many features from other shells, such as csh, ksh, and tcsh.

`C Shell (csh)`: C Shell is a Unix shell developed in the late 1970s. It is similar to the original 
Bourne Shell, but with a few differences. It is designed to be more intuitive than the Bourne Shell 
and it includes features like command-line completion, job control, and aliases.

`Korn Shell (ksh)`: Korn Shell is a Unix shell developed in the early 1980s. It is a superset of the 
original Bourne Shell, meaning it includes all of the features of the Bourne Shell plus additional 
features. It includes command-line completion, job control, aliases, and more.

`Z Shell (zsh)`: Z Shell is a Unix shell developed in the late 1980s. It is designed to be highly 
customizable and it includes features like spelling correction, command-line completion, and 
job control. It is similar to the Korn Shell but with more features.


**[FIXED] Value Does Not Live Long Enough**

As a Rust developer, I'm always looking for ways to make my code safer and more reliable. But I've encountered my fair share 
of errors, and one of the most common is the `value does not live long enough` error. 
I remember my first time trying to debug this issue - it felt incredibly frustrating! But I eventually figured out the cause 
and was able to move forward. At least, when I was able to fix the error, the code just worked and and this is one of the nice
promises of the rust programming language. 
Throught this article, I'll share what I learned about this error, its causes, and how you can troubleshoot and fix it. 
I will try to update this first draft with as much information as possible with what I would learn along the way.

*What is the "Value Does Not Live Long Enough" Error?* 

The `value does not live long enough` error is a compiler error that occurs when a value is used beyond its lifetime. 
This can happen when a value is returned from a function without being stored in a variable or when a reference to 
a value is returned from a function and the value is no longer accessible after the function returns. 

*Causes of "Value Does Not Live Enough"*

When Moving a Value Out of a Variable: 
The most common cause of the `value does not live long enough` error is when a value is moved out of a variable. 
This occurs when a value is assigned to a variable and then the value is moved out of the variable, making the 
original variable unusable. 

Here is in the following an example that results in that error.        

```rust        
let mut x = "My name is Mehdi".to_owned();
let y = x;
// uncomment the statement below to make it work!
// x = "My name is different now!".to_owned();
println!("x is {x} and y is {y}");
```

When returning values from a function: 
Another common cause of the `value does not live long enough` error is when a value is returned from a function. 
This occurs when a value is returned from a function, but the value does not live long enough for the calling 
code to use it. The scope of the value being returned ends at the same place where the function' scope ends.

Let's see with the example below where we declare a local `String` in the function and try to return it to be 
used outside of the function itself:

```rust
fn get_value() -> Vec<u8> {
  let x = vec![1, 2, 3];
  x
}

let y = get_value();
println!("y is {y:?}");
```

When accessing variables from closures: 
The `value does not live long enough` error can also occur when accessing variables from closures. This occurs when 
a variable is accessed from a closure, but the variable does not live long enough for the closure to use it. 

Here is the example that shows that the value that the closure returns goes out of scope and is destroyed before 
the call to the closure itself. It does not live long enough as a consequence. 

```rust
let y = {
  let x = 10;  
  || { x * 10 }
};

let z = y();
println!("z is {z}");
```

When using explicit lifetimes:  
The `value does not live long enough` error can also occur when using lifetimes. This occurs when a lifetime is specified for 
a variable, but the lifetime is shorter than the lifetime of the value. 

The error is triggered in this situation as the reference `&x` lifetime is different from `'static` and in this case it is 
smaller and hence, we are using the wrong explicit lifetime in the code example below. 

```rust 
let x = 5;
{
  let y: &'static u32 = &x;
  println!("y is {y}", y);
}

println!("x is {x}");
```

*How to Fix the "Value Does Not Live Long Enough" Error* 

The explanation in this section is general as I don't want (for the moment) include the solution to all of the situations
where this error appears.  

The first step in troubleshooting and fixing the `value does not live long enough` error is to determine what the lifetime 
of the value is. This can be done by examining the code and looking for any references to the value. Once the lifetime 
of the value has been determined, the next step is to ensure that any references to the value are valid for the entire 
lifetime of the value. This can be done by using lifetime annotations or by storing the value in a variable and then 
referencing the variable. 

Now, let's provide the solution that is not efficient, I must admit, that fixes the error when a value is moved out
of a variable. And you guessed it right, we will use `.clone()` for that. 


```rust
let x = String::from("Hello World!");
//let y = x;
let y = x.clone();
println!("{x} - {y}");    // Error 
```

We simply had to replace the statement `let y = x;` with `let y = x.clone();`.

*Last Words*

Finally, the "value does not live long enough" error is a common problem that many Rust developers are likely 
to encounter. It is caused by the Rust compiler's lifetime rules, and is easily fixed by making sure that all references 
to the value are valid for the entire lifespan of the value. This error is one of the many safeguards provided by 
the borrow checker, which serves to protect against a variety of reference and pointer errors. As a result, Rust 
programmers can rest assured that their code is free from such errors.


**[FIXED] TypeError: datetime.datetime() is not JSON serializable**

In today's short article, I will show you how to fix the error in the title.

*Problem*

Suppose we have the following python `dict`.
```python
sample = {}
sample['title'] = "String"
sample['somedate'] = somedatetimehere
```

When you try to use `jsonify(sample)`, you get the following `TypeError`.

```
TypeError: datetime.datetime(2012, 8, 8, 21, 46, 24, 862000) is not JSON serializable
```

*Solution*

The solution is to subclass the `json.JSONEncoder` class.

```python
from datetime import datetime
import json

class DateTimeEncoder(json.JSONEncoder):
  def default(self, o):
    if isinstance(o, datetime):
      return o.isoformat()

    return json.JSONEncoder.default(self, o)
```

Now, in order to serialize the `dict` object into JSON, you can use the following code.

```python
jsonData = json.dumps(sample, cls=DatetimeEncoder)
```


**Booleans in Golang** https://golangdocs.com/booleans-in-golang

In today's article, we will be looking at how to use booleans in Golang.

*Booleans in Golang*

Booleans in Golang are variables that can take on a value of either `true` or `false` and is of type `bool`. 

Here is an example below an uninitialized boolean variabl is assigned a value of `false`. The
second value is assigned to `false` and the third `Printf` function displays `true`.

```go
package main

import (
    "fmt"
)

func main() {
  var bVal1 bool 
  var bVal2 bool = false
  fmt.Printf("bVal1: %v\n", bVal1)
  fmt.Printf("bVal2: %v\n", bVal2)
  fmt.Printf("bVal3: %v\n", bVal1 == bVal2)
}
```

The program above declares two boolean variables, `bVal1` and `bVal2`. 
`bVal1` is initialized with the default value of `false`, while `bVal2` is explicitly set to `false`. 
The program then prints out the values of both variables, as well as the result of the 
comparison `bVal1 == bVal2` which is `true`.


*What are Relational Boolean Operators in Golang?*

We've had a glimpse of what relational booleans operators are in the last section by using the double 
equal sign operator `==`. 

Let's first defind what those operators are. 

Boolean relational operators in Golang are the operators used to compare two values and return a boolean
result. 
 
They include the `==` (equality) and `!=` (inequality) operators, as well as the `>`, `<`, `>=` and `<=`
(greater than, less than, greater than or equal to, and less than or equal to) operators.

Here is an example that shows how these work. 

```go
package main 
 
import "fmt"
 
func main() {
  a := 10
  b := 5
 
  // comparing a and b using == operator
  if a == b {
    fmt.Println("a is equal to b")
  }
 
  // comparing a and b using != operator
  if a != b {
    fmt.Println("a is not equal to b")
  }
 
  // comparing a and b using > operator
  if a > b {
    fmt.Println("a is greater than b")
  }
 
  // comparing a and b using < operator
  if a < b {
    fmt.Println("a is less than b")
  }
 
  // comparing a and b using >= operator
  if a >= b {
    fmt.Println("a is greater than or equal to b")
  }
 
  // comparing a and b using <= operator
  if a <= b {
    fmt.Println("a is less than or equal to b")
  }
}
```

*What are Logical Boolean Operators in Golang?* 

Logical Boolean Operators in Golang are `&&` (AND), `||` (OR), and `!` (NOT). These operators can be 
used to evaluate two boolean expressions, such as the result of a comparison, and determine 
the outcome of the expression.

```go
package main

import " fmt"

func main() {
	x := true
	y := false

	// AND
	logicalAND := x && y
	fmt.Printf("%t && %t = %t\n", x, y, logicalAND)

	// OR
	logicalOR := x || y
	fmt.Printf("%t || %t = %t\n", x, y, logicalOR)

	// NOT
	logicalNOT := !x
	fmt.Printf("!%t = %t\n", x, logicalNOT)
}
```

The output of the program is as follows. 

```
true && false = false
true || false = true
!true = false
```

*How to Convert from a String to a Boolean Value and Vice Versa in Go*

In Go, you can use the `strconv.ParseBool()` function to convert a string to a boolean value.

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	str := "true"
	value, err := strconv.ParseBool(str)
	if err == nil {
		fmt.Println(value)
	}
}
// Output: true
```

Important note: The `ParseBool()` function will convert any string value that is 
`1`, `t`, `T`, `true`, `True`, `TRUE`, `0`, `f`, `F`, `false`, `False` 
or `FALSE` to its corresponding boolean value.


Here is how to convert a boolean value to a string in Golang using the `string.FormatBool()`
function. 


Here is a full example program.

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	value := true
	str := strconv.FormatBool(value)
	fmt.Println(str)
}
// Output: true
```

**What is 'raise from' in Python**

Today, I've learned a new Python syntax. It may have been there for some time but I've
never paid attention to it until now. 

The first time I encountered this syntax was in a `manage.py` file in a Django project,
like the one below.

```python
import os
import sys

if __name__ == "__main__":
  os.environ.setdefault("DJANGO_SETTINGS_MODULE", "helloworld.settings")
  
  try:
    from django.core.management import execute_from_command_line
  except ImportError as exc:
    raise ImportError(
      "Couldn't import message! "
  ) from exc 
        
  execute_from_command_line(sys.argv)
```

First, let's understand what the `raise` keyword do in Python.

*raise Statement*

The `raise` statement is used to raise an exception in Python. 
Here is below the basic syntax for using it: 

```python
raise ExceptionType(message)
```

The above code will raise an exception of type `ExceptionType` with the specified `message`.

*raise from Statement*

You can also add a `from` clause to specify the original exception that caused the error. 

Here is an example of how it is used.

```python
try: 
  # some code that may raise an exception
  raise SomeExceptionType("The first exception message goes here")
except SomeExceptionType as exc: 
  # handle the exception 
  raise ImportError("Can't import that module!") from exc
```

Now when the code in the `try` block raises an exception of type `SomeExceptionType`, it will be caught 
by the except block. The except block will then raise a new `ImportError` exception with the message 
"Can't import that module!", and specify the original exception `exc` as the cause of the new exception 
using the `from` clause.

*Why Is it Useful?*

The `from` clauses allow you to provide more context and information about the error, especially when working
with multiple layers of code.



**Process vs Thread in Programming**

Processes and threads are two of the most important concepts in computer science. They are the building blocks 
of modern-day operating systems and programming languages, and understanding them is essential for anyone looking 
to program efficiently and effectively. 

I ll try to produce an article about how processes and threads work, how they differ, and how to start a process 
and thread in several popular programming languages.

*What is a Process?*

A process is a program or application running on a computer. It is a collection of instructions 
and associated resources, such as memory and open files, that are managed by the operating system. 
Each process is isolated from the others, and each has its own address space, which means that 
the processes are unable to access each other's memory.

Here is how processes communicate between each other. 

Standard input (`stdin`) and standard output (`stdout`) are the two primary ways that processes communicate with 
each other and with their environment. `Stdin` is used to provide input to a process, while stdout is used to 
provide output from a process. Typically, `stdin` is connected to a keyboard or file and `stdout` is connected 
to a monitor or file. `Stderr` (standard error) is also used to provide output from a process, but is typically 
used to report errors. 

Each operating system has its own set of conventions for how processes interact with their stdin, stdout and 
stderr streams.

*What is an OS Thread?*

An OS thread is a subprocess within a process. It is a unit of execution that can run concurrently 
with other threads. Each thread has its own stack and program counter, which allows it to execute independently 
from other threads. OS threads are managed by the operating system, and they are typically used to improve 
the performance of a program by allowing it to execute multiple tasks at the same time.

In rust, the `std::thread::spawn()` function spawns a new OS thread.

*What is a Green Thread?*

A green thread is an application-level thread that is managed by the application itself, rather 
than by the operating system. Unlike OS threads, green threads are lightweight and can be 
quickly created and destroyed, making them ideal for applications that require high performance 
and scalability. 
Go routines are green threads.


*Start a Process in Python*

To start a process in Python, use the `subprocess` module. Here is how it is done in the example
below and we also print the output of the `ls -l` command. 

```rust
import subprocess

if __name__ == "__main__":
  proc = subprocess.Popen(['ls', '-l'], stdout=subprocess.PIPE)
  for line in proc.stdout:
    print(line.decode('utf-8').strip())
```    

*Start a Process in Golang*

It is simple to start a process in Golang. You will need to use the `exec` package. This 
package provides an easy way to spawn a new process to run a command. 

Here is an example go program below. 

```go
package main

import (
	"fmt"
	"os/exec"
)

func main() {
	cmd := exec.Command("ls", "-l")

	out, err := cmd.Output()
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println(string(out))
}
```

*Start a Process in Rust*

Now, to start a process in Rust, we just need a couple lines of code only. The method is to use
use the `std::process` module. It provides an easy way to spawn a new process and execute 
a command. 

Below, is the code example that shows how to start a process to execute the `ls` command
and then prints the output of the command to the standard output.

```rust
use std::process::Command;

fn main() {
  let output = Command::new("ls")
    .arg("-l")
    .output()
    .expect("Failed to execute command");

  println!("{}", String::from_utf8_lossy(&output.stdout));
}
```

So, what is different between `String::from_utf8_lossy()` and `String::from()` methods?
Both functions create a `String` object. The `from_utf8_lossy` method is used to handle errors 
by replacing any invalid UTF-8 sequences with the Unicode U+FFFD REPLACEMENT CHARACTER that 
might occur during the conversion, whereas the `from` method does not handle these errors.

*Start a Process in JavaScript*

It is easy to start a process using JavaScript. In order to do so, we will use the `child_process`
npm module. This module provides an easy way to spawn a new process and execute a command. 

Here is an example that shows you how to start a process and then print the output of the 
command.

```javascript
const { exec } = require('child_process');

exec('ls -l', (err, stdout, stderr) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log(stdout);
});
```

*Start a Thread in Python*

Here is, in the following, how a thread can be started using the `threading` module.

```python
import threading
import time

def my_function():
  print("Hello from a thread!")
  time.sleep(0.5)

if __name__ == "__main__":
  thread = threading.Thread(target=my_function)
  thread.start()
```

*Start a Thread in Golang*

In Golang, a thread can be started using the go keyword. 
Herre is an example code that shows how to run a function on a separate thread. 

```go
package main

import "fmt"

func myFunction() {
  fmt.Println("Hello from a thread!")
}

func main() {
  go myFunction()
}
```

Here is a little bit more details about threads in Golang. 

Go's M:N threading model assigns Goroutines (G) to be run by the language runtime on operating system threads (M) 
on processors (P). At any given time, only one OS thread can be run on a CPU, but different Goroutines can be 
executed on different OS threads for concurrency. When a blocking operation is encountered, another Goroutine 
can be assigned to the OS thread, and once the call ends, the Goroutine will be reassigned. Parallelism can 
then be achieved as the Goroutines can be distributed across the machine's cores.

In short, M Goroutines are being run on N operating system threads and the M number can be greater than N.

*Start a Thread in Rust*

In Rust, a thread can be started using the `thread` module from the standard library. 
Here is a minimal example that shows how to start a thread in Rust.

```rust
fn my_function() {
  println!("Hello from a thread!");
}

fn main() {
  std::thread::spawn(my_function);
}
```

To the question "Are rust thread the same as OS threads?", here is the answer below.

Yes, rust threads spawned with `std::thread::spawn()` are OS threads. This method creates a new thread in the 
operating system, allowing for concurrent code execution to the main thread. This provides better 
performance and scalability.
However, if overhead is too much, asynchronous tasks can be used instead.

*Start a Thread in JavaScript*

In JavaScript, a thread can be started using the `Worker API`. 
Here is how to create a new worker and spawn a new thread from the main window thread.

```javascript
// main.js
const myWorker = new Worker('./my-worker.js');

myWorker.postMessage("Hi from the main thread!");

// displays "Pong from the worker thread!"
myWorker.onmessage = function onMessage(e) {
  console.log(e.data);
}
```

And here is the content of the worker thread JavaScript file. 

```javascript
// my-worker.js
onmessage = function onMessage(e) {
  // displays "Hi from the main thread!"
  console.log(e.data);
  postMessage("Pong from the worker thread!");
}

```

To the question "is the file passed to the worker constructor being run on a separated thread?", here is the answer.

Yes, the file passed to the worker constructor is being run on a separate thread in JavaScript. The 
`Worker` constructor creates an object that runs in a separate worker thread, and the code that is passed to 
it is executed in this separate thread. This allows for concurrent execution of code in multiple threads, 
allowing for better performance and scalability.



**Install Go in Windows**

As a Windows user, I'm currently using Windows 10 and the Windows Subsystem for Linux as my 
development environment. For this reason, I'm sharing a tutorial on how to install Golang on Windows.

Go is an open source, statically-typed, compiled language created by Google. It's designed for 
concurrency, simplicity, and reliability and is efficient and easy to use. It's great for web 
development, system programming, and more, and can be used on various operating systems, including Windows.

*System Requirements*

Note that Golang can be installed on Windows, MacOS, and Linux. But for our case, I am sharing the 
minimum system requirements for Windows: 
•	Windows 8 or higher
•	64-bit processor
•	At least 4 GB of RAM
•	At least 10 GB of free disk space

Recently, Go language stopped supporting Windows 7.


*Downloading the Go Software* 

Go's msi installer can be downloaded from the official website, `https://go.dev`. The download is available 
in both 32-bit and 64-bit versions. Once the msi installer file is downloaded, you can double-click on it 
to start the installation process.

*Setting the Path Variable* 

Once Golang has been installed, you need to set the `PATH` variable so that the Go compiler can be called 
from the command line. In order to accomplish this, open the `System Properties` dialog box, then click 
on the Advanced tab. On the Advanced tab, click on the `Environment Variables` button. In the Environment 
Variables dialog box, find the `Path` variable and click on it. Click the Edit button, and then add 
the path to the Go compiler (e.g. `C:\Go\bin`). And then, save and exit.  

// todo add screenshots!

*Verifying the Installation* 

To verify that Go has been installed correctly, open a command prompt window and type:

```bash
go version 
```

This should display the version of Go that has been installed. 

**Using 'go fmt' Command**

As a programmer, I have found great value in formatting my source code. Not only does it make it easier 
for me to read and understand, but it also makes it easier for others to do the same. Using the `go fmt` 
command in the CLI has been a great help in auto-formatting my Golang source files according to best practices 
and standards.

*How to Format Golang Code?*
We can use the go fmt command from the `gofmt` package in Golang to automatically format our go source files. 
`gofmt` is a command-line utility that allows us to format go code as per standard semantics and conventions.

Now if we have an unformatted go source file with inconsistent syntax, we can use `go fmt` to clean it up. 
The command will fix any indentations, operators, or any other syntactic inconsistencies in the file.

Consider a large project with multiple packages, modules, and source files. `go fmt` can make it much more readable 
and consistent.

Here is an original `main.go` source file that is unformatted.

```go
package main
 
import     "fmt"

 
func main() {
         var word string
    fmt.Printf( "Enter any string: ")
         fmt.Scan( &word)
    num :=6
      fmt.Println("The number is : ", num )
      }
```

After running the `gofmt main.go` command, we get the following formatted go code. 

```go
package main
 
import (
    "fmt"
)
 
func main() {
    var word string
    fmt.Printf("Enter any string: ")
    fmt.Scan(&word)
    num := 6
    fmt.Println("The number is : ", num)
}
```

*How to Store the New Formatted File in a New File?*

Using the `>` shell operator, we can store formatted code in a new file. This operator helps define the refactoring 
file and the original source file to be refactored. 

The syntax for the command for this is:
```bash
gofmt original_file.go > output_file.go
``` 

Here is an example, we can enter the following command to store the formatted code in a new file.

```bash
gofmt main.go > formatted_main.go
```

*How to Display the Changes Made by the 'go fmt' Command?*

The `fmt` command can be used to generate a diff of the formatted code to a different file using the `-d` flag.
To store the changes of the diff in the source file into another diff file, we can use the `>` shell operator. 

Here is the syntax for the command:
```bash
gofmt -d original_file.go > diff.go
```

So with this command we can append the output of the `diff` command in the mentioned file, in this case `diff.go`. 

*What is the Difference Between 'go fmt' and 'gofmt'?*

The difference between `gofmt` and `go fmt` is that `gofmt` takes file system paths as arguments, while `go fmt` 
takes packages as arguments. Additionally, `gofmt -l -w` is applied to the packages specified by go fmt, while 
gofmt only takes the arguments specified.

The `-l` flag prints the name of modified files.

The `-w` flag writes the result back to the source file.


**What is go.mod File?**

In today's article, I share with you everything I know about the `go.mod` file and what is its role in
a golang project.

*What is go.mod File?*

The `go.mod` file is something I've been curious about for a while but never looked into since my applications 
were working as expected. This file is the root of dependency management in GoLang, storing information about 
the modules and packages used in a project, as well as the version of the Go language. When the `go mod init` 
command is used, a `go.mod` file is created with the module path and Go version information, and every package 
building command will update it with the latest versions. Additionally, a `go.sum` file is created containing 
checksums of each package to stop unnecessary reinstalls when the project is run again. The modules and packages 
downloaded are stored in the module cache directory located in `$GOPATH/pkg/mod`.

*Example go.mod File*

Here is an example of a `go.mod` file. 

```
module myProject

go 1.14

require (
	github.com/golang/net v0.0.0-20201006133043-e89a7a53c133
	github.com/golang/text v0.3.2
)

replace github.com/golang/net => ../net
```

Now, after installing the go gin framework using the command:
```bash
go get -u github.com/gin-gonic/gin
```

We get the following updated `go.mod` file. 

```
module myProject

go 1.14

require (
	github.com/gin-gonic/gin v1.6.3
	github.com/golang/net v0.0.0-20201006133043-e89a7a53c133
	github.com/golang/text v0.3.2
)

replace github.com/golang/net => ../net
```

*What is the Difference Between go.mod and go.sum Files?*

Go.mod is the root of dependency management in Golang. It is a file that stores information about 
the modules and packages used in a Golang project, as well as the version of the Go language used. 
It is updated when running any package building command with the latest versions of the packages.

Go.sum is a file that is generated by the `go mod init` command. It stores a checksum of each package 
in order to prevent reinstalling the same packages when the project is run again. Additionally, 
the `go.sum` file is used to verify the integrity of packages from the module cache directory located 
in `$GOPATH/pkg/mod`.

Here is the go.sum file content from the previous example project.

```
github.com/gin-gonic/gin v1.6.3/go.mod h1:FoaE6OiO6uZ+B9X2QdJODVlhfBzP7VUdmTfhR7ydb0Q=
github.com/golang/net v0.0.0-20201006133043-e89a7a53c133 h1:LX/Y8R/lFnH2y/h4g4BQmWbE/mvrtjxLF07hX5YdDc=
github.com/golang/text v0.3.2/go.mod h1:A/NhV/jYGPdQ7VU/BwzgHdA/RfUo7mI9TukTQ7V3qE8=
```

*What Does 'go mod init' Do?*

Go mod init is a command used to create a new module, initializing the `go.mod` file that describes the 
module. When this command is run, it will create a `go.mod` file which will contain information about 
the module path and the go version. Additionally, it will also create a `go.sum` file which stores a 
checksum of each package to prevent reinstalling the same packages when the project is run again.

*What Does 'go mod tidy' Do?*

`Go mod tidy` is a command that is used to tidy up the `go.mod` file. It removes any unused modules, 
updates existing modules to the latest version, and adds missing modules that are needed. It also 
updates the `go.sum` file with the latest checksums of the packages. This command is used to maintain 
the integrity of the project and ensure that all packages are up to date.


*What Does 'go clean -modcache' Do?*

`Go clean -modcache` is a command used to delete the module cache directory located in `$GOPATH/pkg/mod`. 
This command is used to clear the cache of any downloaded packages and modules, so that the project will 
be forced to download the latest versions of the packages and modules when it is run again.


**Rust Dynamic Dispatch using the 'dyn' Trait Objects**
//todo

*Transmuting vtable*

```rust
#![feature(raw, const_transmute)]
#![deny(bare_trait_objects)]

use ::std::*;

pub trait Trait {
    fn method_1 (&'_ self);
    fn method_2 (&'_ self, _: i32) -> i32;
}

struct Double;
impl Trait for Double {
    fn method_1 (self: &'_ Self) {
        eprintln!("Double");
    }
    fn method_2 (self: &'_ Self, x: i32) -> i32 { 2 * x }
}

struct Triple;
impl Trait for Triple {
    fn method_1 (self: &'_ Self)
    {
        eprintln!("Triple");
    }
    fn method_2 (self: &'_ Self, x: i32) -> i32 { 3 * x }
}

const DOUBLE_AS_DYN_TRAIT_VTABLE: *mut () = unsafe {
    mem::transmute::<*const dyn Trait, raw::TraitObject>(
        ptr::null::<Double>()
    ).vtable
};

fn foo (object: &'_ dyn Trait) {
    object.method_1();
    let _ = object.method_2(42);
}


fn main () {
  dbg!(DOUBLE_AS_DYN_TRAIT_VTABLE);
  foo(&Double);
  eprintln!("vtable: {:p}",
    unsafe { mem::transmute::<&dyn Trait, raw::TraitObject>(&Double) }.vtable,
    // unsafe { **(mem::transmute::<&dyn Trait, raw::TraitObject>(&Double).vtable as *mut *mut usize) },
  );
  foo(&Triple);
  eprintln!("vtable: {:p}",
    unsafe { mem::transmute::<&dyn Trait, raw::TraitObject>(&Triple) }.vtable,
  );


  eprintln!("vtable: {:p}", unsafe { mem::transmute::<&dyn Trait, raw::TraitObject>(&Triple) }.vtable);
}
```

**What Are $0, $1 and $2 in Shell?**

I want to improve my knowledge of how to use variables in the Shell, particularly variables that begin with the dollar sign. 
In that sense, writing about the subject helps tremendously. 

So, in Linux and Unixs shells, the `$0`, `$1` and `$2` are positional parameters that refer to the arguments passed to a shell 
script or a command.

*Answer*

`$0` represents the name of the command itself.

`$1` is the first argument of the given command. 

`$2` is the second argument of the same command.  

For instance, here is how it works. 

```bash
 echo hello world 
# $0   $1    $2
```

Soe `$0` is “echo”, `$1` is “hello”, and `$2` is “world”. 

These variables are helpful when scripting multiple arguments, as one can use $1, $2 and so on to access them. Moreover, $@ contains all of the arguments passed to the script, which allows one to process any number of arguments. In conclusion, $0, $1 and $2 are positional parameters in Linux and Unix shells that can be used to access any number of arguments.

Write a complex example of their usage

The following example shows a shell script that takes three arguments and prints them out.
```bash
#!/bin/bash

# Print out the three arguments

echo Argument 1: $1
echo Argument 2: $2
echo Argument 3: $3

# Do something with the arguments

if [ "$1" = "hello" ]; then
	echo "You said hello!"
fi

if [ "$2" = "world" ]; then
	echo "You said world!"
fi

if [ "$3" = "foo" ]; then
	echo "You said foo!"
fi
```

This script will print out the three arguments that are passed to it. It will also check if the first argument is "hello", the second argument is "world" and the third argument is "foo", and if so, it will print out a message.

To use this script, we would call it like this:

./myscript.sh hello world foo

This would print out the three arguments, and then print out the messages about saying hello, world and foo.

Write another different complex example with its explanation

The following example shows a shell script that uses the special variable $@ to process an unlimited number of arguments.

```bash
#!/bin/bash

# Print out each argument

for arg in "$@"; do
	echo Argument: $arg
done

# Do something with each argument

for arg in "$@"; do
	if [ "$arg" = "hello" ]; then
		echo "You said hello!"
	fi

	if [ "$arg" = "world" ]; then
		echo "You said world!"
	fi
done
```

*Todo add screen shots!*



This script will print out each argument that is passed to it. It will also check if any of the arguments are "hello" or "world", and if so, it will print out a message.

To use this script, we would call it like this:

./myscript.sh hello world foo bar

This would print out each of the four arguments, and then print out the messages about saying hello and world.


*How About the Flags Are the Flags Can be Accessed with $ Parameters?*

Yes, flags can be accessed with `$` parameters as well. A flag is a single-character option that changes the behavior of a command. 
For example, the “-v” flag is often used to show verbose output for a command. In order to access these flags, one must use the 
special variable `$@`. This variable contains all of the arguments passed to the script, so it can be used to access any flag that 
is passed to the script. For example, if the command is “echo -v hello world”, then `$@` is an array that will contain the elements
“-v”, “hello” and “world”. 
In that sense, this allows one to access the flag “-v” and process it accordingly.


*Are There Other Shell Parameters I Should be Aware Of?*

Yes, here is a brief summary of the other important shell parameters:

- $@ is an array-like construct of all positional parameters, {$1, $2, $3 ...}.
- $* is the IFS (internal field separator) expansion of all positional parameters, $1 $2 $3 ....
- $# is the number of positional parameters.
- $- is the current options set for the shell.
- $$ is the PID of the current shell (not subshell).
- $_ is the most recent parameter (or the abs path of the command to start the current shell immediately after startup).
- $IFS is the (input) field separator (usually a space).
- $? is the most recent foreground pipeline exit status.
- $! is the PID of the most recent background command.
- $0 is the name of the shell or shell script.

You might ask, what is IFS expansion?
Basically, all the positional arguments are stored in a single string.


**Btoa vs Atoi in JavaScript**

In JavaScript, `btoa` and `atoi` are two different functions that provide different services. 

`Btoa` stands for "Binary to ASCII" and is used to convert a binary string into a base 64-encoded 
ASCII string. 

`Atoi` stands for "ASCII to Integer" and is used to convert a base 64-encoded ASCII string into a 
number.

The `btoa` function can be used to convert a string of binary data into an ASCII string. This can be 
useful for encoding binary data, such as images, into a format that can easily be sent over the network.
It takes a binary string as an argument and returns a base 64-encoded ASCII string.

On the other hand, `atoi` function can be used to convert an ASCII string into a number. This can be 
useful for decoding a base 64-encoded ASCII string and converting it back into a number. It takes an 
ASCII string as an argument and returns an integer.

*Word of Caution*
It is important to note that btoa should not be used for encoding sensitive data, as it is not a secure 
form of encryption. The atoi function can be used to convert encrypted data back into its original form, 
but it is important to remember that it is not a secure form of encryption either.


*Btoa Example*
Here is an example where we will take a binary string, representing a binary number, and convert it 
into a base 64-encoded ASCII string. To do this, we use the `btoa()` function:
```javascript
let binaryString = '10101010';
let encodedString = btoa(binaryString);
```
The output of this example is: 

```text
MTAxMDEwMTA=
```

*Atoi Example*
The example below shows how to take a base 64-encoded ASCII string, and convert it into a number. 
To do this, we use the atoi function, like so:

```javascript
let encodedString = 'QWxhZGRpbjpvcGVuIHNlc2FtZQ==';
let number = atoi(encodedString);
```

The output of this example is as follows:
```text
4348520605
```
**How to Search in Github.com**

If you're dealing with rapidly changing services, projects or environments, like AWS, reading the docs can be 
cumbersome and lack examples. 
To find a solution to your problem, you can either google around or search GitHub for examples. 
On GitHub.com, you can search millions of public repositories for the keywords you're looking for. If you select a 
specific repository, then your search will be limited to that repository. 

So, if you're looking for a solution to your problem, try searching GitHub.com!

*Github Search Examples*

Searching for code on GitHub is easy. You can filter by language, file extension, user, repository, filename, and more. 


So for example, if you want to search for the term `s3.deleteBucket` using typescript, use the command:
```shell
s3.deleteBucket language:typescript
``` 

Now, if you want to search for `s3.deleteObject` using the file extension `.js`, use:
```shell
s3.deleteObject extension:js
```

When searching for a term with whitespace, like `new CfnAuthorizer`, you'll need to use quotation marks. 
```shell
"new CfnAuthorizer" language:typescript
```

To search for code in all of a user's or organization's repositories use the user or org qualifier, and for a 
specific repository use the repo qualifier. 
Here is how it is done:
```shell
user:randimicon00 extension:py
```
This will match code from `@randimicon00` with the file extension `.py`. 

To exclude keywords when filtering, use the command with the `NOT` keyword.
```shell
deploy NOT staging
```
The above command will search for files with the word "deploy" that do not have the word "staging".


Lastly when commits authored by a user use `author:username`, and to match issues assigned to the person 
viewing the results use:
```shell
is:issue assignee:@me
```

*More Github Search Examples*

Search for the term `push notification` by filtering the language to JavaScript:
```shell
"push notification" language:javascript
```

Search for files with the word "config" that have the file extension .json:
```shell
config extension:json
```

Match commits authored by the user `@randimicon00` with the word `update` in the commit message:
```shell
author:randimicon00 update
```

**How to Get the First N Digits of a Number in Python**

In today's article, I will show you how to get the first N digits of a number in Python. 

*Explanation*

To get the first N digits of a number, convert it to a string using the `str()` built-in function that converts a number to a
string, then use string slicing to select the desired amount of characters, and finally convert the result back to an integer 
using the `int()` Python built-in function.

*Example Code*

```python
# (3434, 2)
number = 3434
n = 2
number_string = str(number)
first_n_digits = int(number_string[:n])
print(first_n_digits) 

# (22, 1)
number = 22
n = 1
number_string = str(number)
first_n_digits = int(number_string[:n])
print(first_n_digits)

# (643439, 5)
number = 643439
n = 5
number_string = str(number)
first_n_digits = int(number_string[:n])
print(first_n_digits)

# (123479, 3)
number = 123479
n = 3
number_string = str(number)
first_n_digits = int(number_string[:n])
print(first_n_digits)
```

Let's provide more details about how the first conversion works. 
The code starts with the variable number, which holds the integer `3434`.
We then use the `str()` function to convert the integer to a string.
Next, we use the slice `number_string[:2]` to extract the first two characters of the string.
Finally, we use the `int()` class to convert the string to an integer. The result is `34`, 
which is printed to the console.


The output of the whole program is as follows:
```text
34
2
64343
123
```

*Helper Function*

The following helper function, `get_first_digits()` can be used to get the first N digits of a given number.

```python
def get_first_digits(input, n = 1):
    number_string = str(input)
    first_n_digits = int(number_string[:n])
    return first_n_digits
```

The above helper function converts the given number `input` to a string, then uses string slicing to select the 
desired amount of characters and finally converts the result back to an integer. 
The `n` parameter is optional and defaults to `1`.

Here is how we can use the helper function below. 
```python
# (123479, 3)
number = 123479
n = 3

first_n_digits = get_first_digits(number, n)
print(first_n_digits)
```

The output is shown below. 
```text
123
```

**How to View Expanded Code of Macros in 2023**

Rust's macros are a great way to save time and effort when writing code. They allow you to write less code, 
reducing the risk of repetitive strain injuries to your hands and fingers!

*Problem*
However, sometimes this concise code can cause errors that can be difficult to debug. In order to debug these errors, 
you need to be able to see the expanded code of the macro. 

*Solution*
Previously, you could do this by passing the `--pretty` argument with the unstable-options flag. However, starting with `nightly-2021-07-28`, this argument has been removed.

Now, the right way to expand macros code is to pass `-Zunpretty=expanded` when compiling your code with the rust compiler 
executable `rustc`. Here is below the command to run: 

```shell
rustc -Zunpretty=expanded code_with_macro_to_expand.rs
```

Alternatively, you can run the following command when using `cargo`:

```shell
cargo rustc -- -Zunpretty=expanded
```

Check the relevant rustc commits for this feature were added to `nightly-2018-01-24` and `nightly-2021-07-28`. 

This new feature makes it much easier to debug macro-related errors in Rust and can help you get to the root of 
the problem quickly. With this new feature, you can be sure your Rust code is running smoothly and efficiently.

*Alternative Solution*
Here is an alternative solution by `dtolnay`, a prominent rust developer, which makes use of the `cargo-expand` crate. 

The crate will install and provide the cargo subcommand `cargo expand` that prints the fully expanded version of your 
code after macro expansion, and also automatically formats it with `rustfmt` for a much more readable output than the 
default from rustc. 

To install, just run:
```shell
cargo install cargo-expand
```

*Solution Using rust-analyzer in VSCode*
If you would like to view the expanded code before compiling, `rust-analyzer` (a VSCode extension for Rust language) 
offers a handy feature called `Expand Macro Recursively`.


**Golang MySQL CRUD Tutorial**

In today's tutorial, I will show you how to create, read, update and delete rows in a MySQL database using a 
golang client and connection.

*How to Install MySQL?*

First, we need to update the apt package list. 
Open a terminal and run the command:
```shell
sudo apt update
```
This is done to retrieve the latest package list from the Ubuntu servers. 

Second, we can install the mysql server package.
In the same terminal, run the command:
```shell
sudo apt install mysql-server
```

This will install the MySQL server package.

The third step is to proceed to a secure installation.
After the installation, run the command:
```shell
mysql_secure_installation
```

This is done to secure the installation with a root password and other security settings. 

Now, we can start the MySQL service. 
Run the command:
```shell
sudo systemctl start mysql
```
This will start the service.

Last but not least, we verify the installation. 
Run the command:
```shell
sudo systemctl status mysql
``` 
This is done to verify that the MySQL service is up and running. 
The output should display the MySQL version, uptime, and port number.

*Get the Golang MySQL Pacakge*
To access a MySQL database in Golang, we need to install the `go-sql-driver/mysql` package. It is a lightweight and 
fast MySQL driver for Go/Golang's database/sql package. 

To install this package, we can use the following command in the terminal: 

```shell
go get -u github.com/go-sql-driver/mysql
```

*MySQL Table*

This database consists of posts that have an id as the primary key, along with strings for firstname, lastname, role and company.

Let's take a look at how to use MySQL with Go. 

Consider this B2B customer table structure: 

```go
type Customer struct {
    Id int
    FirstName string
    LastName string
    Role string
    Company string
}
```

Now, let's create a connection to check if it is working properly. 

```go
db, err := sql.Open("mysql", "<user>:<password>@/<databasename>")
ErrorCheck(err)

// Close the database after all work is done
defer db.Close()
PingDB(db)
```
The `PingDB` function's definition looks like this. 

```go
func PingDB(db *sql.DB) {
    err := db.Ping()
    ErrorCheck(err)
}
```

And the error checking function is as follows. 

```go
func ErrorCheck(err error) {
    if err != nil {
        panic(err.Error())
    }
}
```

Now that the connection is established, let's create, read, update and delete customer entries in the database.

*Create*

Now we can start inserting data into it using code.

Below is the Golang code that inserts a customer entry.

```go
// INSERT INTO DB
// prepare  
stmt, err := db.Prepare("insert into customers(id, FirstName, LastName, Role, Company) values (?, ?, ?, ?, ?)")
ErrorCheck(err)

// execute
res, err := stmt.Exec("5", "John", "Doe", "Manager", "ABC Company")
ErrorCheck(err)

id, err := res.LastInsertId()
ErrorCheck(err)

fmt.Println("Insert id", id)
```

*Read*

Now, we can easily access all the data by simply running a query. We can iterate through the rows and store 
the data in our struct.
```go
// Query all data
rows, err := db.Query("select * from customers")
ErrorCheck(err)

// Declare empty customer variable
var customer = Customer{}

// Iterate over rows
for rows.Next() {
  err = rows.Scan(&customer.Id, &customer.FirstName, &customer.LastName, &customer.Role, &customer.Company)
  ErrorCheck(err)
  fmt.Println(customer)
}
```

This code queries all data from the customers table in a database and stores the results in a 
Customer struct. 
It then iterates over all the rows, scanning the data and storing it in the Customer struct before printing 
the struct to the console.

*Update*

Here is how to update a column of a specific customer entry. 

```go
// Update database
stmt, err := db.Prepare("UPDATE customers SET Role=? WHERE id=?")
ErrorCheck(err)

// Execute
res, err := stmt.Exec("Marketing Intern", "10")
ErrorCheck(err)

aff, err := res.RowsAffected()
ErrorCheck(err)

fmt.Println(aff) // 1
```

This code updates the `role` of the customer with the `id` of `5` to `Marketing Intern` in the database. It 
also prints out the number of affected rows `1` to the console.

*Delete*

Deleting data is straightforward. Here is an example of deleting by id:

```go
// Delete data
stmt, err := db.Prepare("delete from customers where id=?")
ErrorCheck(err)

// Delete 10th customer
res, err := stmt.Exec("10")
ErrorCheck(err)

// Number of affected rows
a, err := res.RowsAffected()
ErrorCheck(err)

fmt.Println(a)     // 1
```

It deletes the customer with the corresponding id.

*Example Golang MySQL Code*

```go
import (
    "database/sql"
    "fmt"
    _ "github.com/go-sql-driver/mysql"
)
 
type Customer struct {
    Id int
    FirstName string
    LastName string
    Role string
    Company string
}
 
func main() {
    db, e := sql.Open("mysql", "root:somepass@/customers")
    ErrorCheck(e)
 
    // close database after all work is done
    defer db.Close()
 
    PingDB(db)
 
    stmt, e := db.Prepare("insert into customers(id, FirstName, LastName, Role, Company) values (?, ?, ?, ?, ?)")
    ErrorCheck(e)
 
    res, e := stmt.Exec("10", "Ben", "Harrison", "Devops Engineer", "Alphabet Inc")
    ErrorCheck(e)
 
    id, e := res.LastInsertId()
    ErrorCheck(e)
 
    fmt.Println("Insert id", id)
 
    stmt, e := db.Prepare("update customers set Role=? where id=?")
    ErrorCheck(e)
 
    // execute
    res, e := stmt.Exec("Marketing Manager", "10")
    ErrorCheck(e)
 
    a, e := res.RowsAffected()
    ErrorCheck(e)
 
    fmt.Println(a)
 
    // query all data
    rows, e := db.Query("select * from customers")
    ErrorCheck(e)
 
    var customer = Customer{}
 
    for rows.Next() {
        e = rows.Scan(&customer.Id, &customer.FirstName, &customer.LastName, &customer.Role, &customer.Company)
        ErrorCheck(e)
        fmt.Println(customer)
    }
 
    // delete data
    stmt, e := db.Prepare("delete from customers where id=?")
    ErrorCheck(e)
 
    // delete 5th customer
    res, e := stmt.Exec("10")
    ErrorCheck(e)
 
    // affected rows
    a, e := res.RowsAffected()
    ErrorCheck(e)
 
    fmt.Println(a) // 1
}
 
func ErrorCheck(err error) {
    if err != nil {
        panic(err.Error())
    }
}
 
func PingDB(db *sql.DB) {
    err := db.Ping()
    ErrorCheck(err)
}
```

*What Package can be Used to Connect to PostgreSQL in Golang?*

To connect to PostgreSQL in Golang, the recommended package is `github.com/lib/pq`.

*What Package can be Used to Connect to MongoDB  in Golang?*

To connect to MongoDB in Golang, the recommended package is `go.mongodb.org/mongo-driver`.

*How to Update Several Rows in a MySQL Table with Golang?*

First, to update several rows in MySQL with Golang, you can use the MySQL UPDATE statement in combination with the 
WHERE clause. 

Here is the syntax of the update query for several row. 

```sql
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
```

Here is an example of how it is done in Golang. 
Firs you need the `database/sql` package. You can use the `DB.Exec()` function to execute the MySQL UPDATE statement. 

Below is an example code.

```go
// Prepare the SQL statement
sqlStatement := `
UPDATE table_name
SET column1 = ?, column2 = ?, ...
WHERE condition;`

// Execute the UPDATE statement
_, err := db.Exec(sqlStatement, value1, value2)
if err != nil {
	// Handle error
}
```


**Why You Might Hate the Rust Programming Language?**

Rust is a general-purpose programming language that first appeared in 2010. It has been gaining popularity in the past 
years due to its promises of enhanced safety and performance. 
As a software engineer, I was eager to learn Rust and give it a try. 
After trying it out, however, I quickly realized that my relationship with Rust is complicated.

*Reasons why I Hate Rust*

`1. Compilation process is long and tedious`: The language is known for its slow compilation process, which often 
frustrates developers who are used to working with languages with faster compilation times. This is due to its 
reliance on the LLVM compiler, which is not as efficient as some other programming languages. However, it is 
possible to makethe compilation process more efficient, it's important to leverage the most up-to-date compiler 
optimizations and to be honest the compilation time is just slow during the first compilation. Incremental compilation
is often a fraction of the first compilation. It is also possible to break down the project into workspaces which 
is another way to hasten the compilation time. Finally, using a build system like Bazel can speed up the compilation 
process by parallelizing tasks and caching intermediate outputs.

`2. Unintuitive syntax`: Rust has a rather unusual syntax which may be confusing and difficult to learn for developers 
accustomed to working with more intuitive languages. While Rust may be more challenging to master than languages such 
as Python, its powerful features and performance make it a viable option for many projects. However, those who value 
intuitivity should bear in mind that Python is generally a more intuitive language, and has consequently seen 
tremendous popularity in recent years.

`3. Poor documentation`: Rust's documentation can be hard to understand and is not as comprehensive as other languages. This 
can be an issue for developers who are accustomed to working with languages with better documentation. For instance, 
the documentation about atomic variables is minimal and is simply copied from C++ documentation, leaving developers to 
consult C++ documentation and theoretical articles to understand how they work and how to use them. Additionally, 
the documentation about macros can be cryptic, and only through practice and time do developers come to understand and 
be able to write a macro on their own. While the folks behind Rust try to act smart, often the documentation is not 
helpful, leaving developers to research advanced topics on their own initiative.

`4. Difficulty learning and understanding`: Learning and understanding Rust can be a challenge, especially for those who 
are new to programming. To get the most out of Rust, it's essential to spend time mastering the language and understanding 
its nuances. The best way to do this is to start small with a real-world project, such as porting an existing popular 
Git repository into Rust. With this approach, you'll be able to quickly apply your knowledge and learn from your mistakes,
helping you to become more comfortable with Rust and its features. As you progress, you'll also be able to take on more 
complex tasks and further develop your skills. With dedication and practice, you can eventually become an expert in Rust.
Note that you might feel like not making any progress at all for some time and this is perfectly normal, just keep
moving forward.


*Not Giving Up*

Despite my dislike for the Rust programming language, I am still open to learning and using it. I understand that everyone 
has different opinions and preferences, and I am willing to give Rust a chance. I am willing to put in the effort and learn 
the syntax, documentation, and library support. I am also willing to give the language a fair chance and see if I can 
benefit from its features.
I am also willing to take part in rust open source projects like the compiler itself, deno and rust-analyzer, to name a 
few.

*Conclusion*

I have been a low level software/electrical engineer since the year 2000 and though I have used C/C++ extensively for 
a couple of years, I am now looking to switch to a modern and safe alternative. Rust is that alternative, however, it 
has a multitude of drawbacks. The compilation process is long and tedious, its syntax is unintuitive, the documentation 
is poor, the language is unstable, the performance is poor, the library support is limited, and the learning curve is 
difficult. 

Despite these issues, Rust can be a great language for those who have the time and patience to learn. Ultimately, I would 
not recommend Rust for anyone looking for an easy to learn programming language. However, for those of us who 
enjoy understanding how computers work and desire a safe and modern alternative to C/C++, Rust is worth the effort.

**What is a Manifest in the Context of the Rust Programming Language?**

A manifest is a file in the Rust programming language that contains metadata about a Rust project. 
It is typically named Cargo.toml and is used to define the project's dependencies, build instructions, and other 
configuration options. The manifest also specifies the root module for the project, which is the entry point for compilation.

*Cargo.toml vs Cargo.lock*
Cargo.toml is a file that contains metadata and instructions about a Rust project, while Cargo.lock is a file that 
contains a snapshot of the project's dependencies and their versions. Cargo.toml is used to define the project's 
dependencies, build instructions, and other configuration options, while Cargo.lock is used to store the exact 
versions of the project's dependencies that are currently being used. 


*Cargo.toml == Manifest?*

Yes, Cargo.toml can be referred to as a manifest. A manifest is a file in the Rust programming language that contains 
metadata about a Rust project. It is typically named Cargo.toml and is used to define the project's dependencies, 
build instructions, and other configuration options. The manifest also specifies the root module for the project, 
which is the entry point for compilation.

*What is the Purpose of the Cargo.toml File?*

The Cargo.toml file is used to define the project's dependencies, build instructions, and other configuration options. It 
also includes the root module for the project, which is the entry point for compilation.

*How do I Edit the Cargo.toml File?*

You can edit the Cargo.toml file directly, or you can use a text editor or IDE that can interpret the TOML syntax, such
as VSCode with the right extensions.

*What is the Difference between 'dev-dependencies' and 'dependencies' in Cargo.toml?*

The `dependencies` are libraries/crates that your project needs to compile and run. 
On the other hand, `dev-dependencies` are libraries/crates that are only needed for development and testing, such 
as testing frameworks and linting tools.

*What are the different sections of a Cargo.toml file?*

The Cargo.toml file is divided into sections for specifying the project's metadata, dependencies, build instructions, and 
other configuration options.

*What is the best practice for versioning my dependencies in Cargo.toml?*

It is best practice to use the tilde (~) or caret (^) operator when specifying version ranges in Cargo.toml. The tilde 
operator allows patch-level updates, while the caret operator allows minor-level updates.

In the example below, the dependency must be version `1.2.3` or higher, but never greater than the next minor 
version `1.3.0`.

```toml
[dependencies]
my-dependency = "~1.2.3"
```
If you wish to use any version greater than 1.2.3, but not higher than the major version `2.0.0`, you would specify it 
as follows:

```toml
[dependencies]
my-dependency = "^1.2.3"
```

*8. What is a Cargo Workspace and How do I Use it?*

A Cargo workspace is a directory that contains multiple Rust projects and their dependencies. You can use a 
workspace to manage multiple projects and their dependencies in a single place. To create a workspace, create a 
directory, add the projects and their dependencies to it, and then run the `cargo build` command.

Here is an example of a project with two workspaces.

```text
workspace
├── project_1
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── project_2
    ├── Cargo.toml
    └── src
        └── main.rs
```

Here is how you define them in your Cargo.toml file.

```text
[workspace]
members = [
    "project_1",
    "project_2"
]
```

By breaking up projects into workspaces, you end up with a more manageable code base and shorter compile times.


**What Does @type Means in JavaScript?**

*Problem*
I stumbled upon the following code in a SvelteKit component and I wondered what it meant.

```typescript
/** @type {import('./$types').ActionData} */
```

*Solution/Answer*

`@type` is a JSDoc type annotation used in JavaScript to specify a TypeScript type. It allows the programmer to indicate which 
type a variable or expression should be treated as. 

For instance, in the following code there is a variable `actionData` should be treated as an object of type `ActionData`:

```typescript
/** @type {import('./$types').ActionData} */
let actionData;
```

Here is another example. 

```javascript
/** @type {string} */
let name = 'John';

/** @type {number[]} */
let numbers = [1, 2, 3, 4];

/** @type {import('./User').User} */
let user = new User('John', 25);
```

```javascript
// User.js
export class User {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  getName() {
    return this.name;
  }
  setName(name) {
    this.name = name;
  }

  getAge() {
    return this.age;
  }
  setAge(age) {
    this.age = age;
  }
}
```

The `@type` JSDoc type annotation is used in the above code to indicate the type of each variable. The first example indicates that 
the variable `name` should be treated as a `string`. The second example indicates that the variable `numbers` should be 
treated as an array of numbers. The third example indicates that the variable `user` should be treated as an object of 
type `User`.

*What is an @type annotation in JavaScript?*
An `@type` annotation is a way to specify a TypeScript type in JavaScript. It allows the programmer to indicate which type 
a variable or expression should be treated as.

*Why would I use an @type annotation?*
An `@type` annotation can be used to ensure that the variable or expression is treated as the correct type and prevent errors 
caused by incorrect type conversion.

*What type of information can I specify with an @type annotation?*
You can specify any valid TypeScript type with an `@type` annotation, including strings, numbers, arrays, objects, classes, 
and more.

*Does the @type annotation work in all browsers?*
No, the `@type` annotation is a feature of TypeScript and is not supported by all browsers.

*Is the @type annotation the same as a typecast?*
No, @type annotations are not the same as typecasting. Typecasting is used to force a variable to be treated as a particular 
type, while an `@type` annotation is used to indicate what type a variable should be treated as.

**What is manifest.json File?**

`Manifest.json` is a JSON-formatted text file that stores metadata related to a web application. It serves as a source of 
information for the browser, containing information such as the application's name, version, author, and description. 
This file allows the browser to gain insight into the application and its purpose.


Using a `manifest.json` file allows web developers to create progressive web applications that offer an app-like experience 
to users. It can be used to configure the application's startup, the JSON data to be loaded, and the way the application 
should be displayed when launched.

*Manifest.json Step by Step Tutorial*

Here is how to create a manifest.json file in your front-end application's project.

First, create a text file called `manifest.json`.

Now, inside the file, enter the following code:

```json
{
  "name": "My App",
  "short_name": "My App",
  "start_url": "/index.html",
  "display": "standalone",
  "icons": [
    {
      "src": "/images/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
    "src": "/images/icon-512.png",
    "sizes": "512x512",
    "type": "image/png"
    }
  ],
  "theme_color": "#FFFFFF",
  "background_color": "#FFFFFF"
}
```

The next step is to replace values of the `name`, `short_name`, `start_url` and `icons` attributes with your own values.

Now, it is time to add any additional properties required for your application and save the file.

You can now upload the manifest file to the root directory of your web application.

The last step is to reference the manifest file in your HTML page by adding the following tag in the `<head>` section:

```html
<link rel="manifest" href="/manifest.json" />
```

And that's about it! Now, your front-end application has has a manifest file that can be used to provide information about 
the application to the browser.


*Manifest.json File Example*

Here is another example of a manifest.json file:

```json
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
```

This `manifest.json` file is used to configure a React application. It includes information such as the application's name, 
version, author, description, and more. 
The `short_name` and `name` attributes are used to specify the name of the application. The `icons` array specifies the icons 
to be used for the application. The `start_url` attribute specifies the URL to be loaded when the application is launched. 
The `display` attribute is used to specify how the application should be displayed when launched. The `theme_color` 
and `background_color` attributes are used to specify the theme and background colors of the application.

*What is the purpose of the manifest.json file?*
The file is used to store metadata associated with a web application. It is a JSON-formatted text file used to provide 
information about the application to the browser.

*What information can be included in the manifest.json file?*
The file can include information such as the application's name, version, author, description, icons, 
start_url, display, theme_color, and background_color.

*How do I create a manifest.json file?*
To create such file, create a text file called `manifest.json` and enter the relevant JSON code. Then, 
upload the file to the root directory of your web application and reference it in the HTML page.


**Docker File Tutorial**

Docker is an invaluable tool for developers, allowing them to quickly create and deploy applications to any system, regardless of the 
underlying operating system. It does this by packaging applications and dependencies into virtual containers that can be deployed 
on any system. Docker's container technology makes it a powerful and convenient way for developers to quickly and easily deploy 
their applications.

*Docker Benefits*

Docker reduces the need for developers to manage their own machines and hardware, enabling them to create and deploy applications more 
rapidly and effortlessly. Containers are also portable and can be deployed on any platform, irrespective of the operating system. 
This allows developers to take advantage of the numerous benefits Docker provides.

Here are five bulletpoints that summarize the benefits of Docker:

- Improved scalability and availability 
- Increased portability and compatibility 
- Easier container deployment and management
- Improved security and isolation
- Reduced resource utilization and costs


*Docker File Setup*

Ensure the Docker file is in the correct directory and its structure is correct for proper execution of commands. 
Wrong directory or incorrect structure can lead to commands not being executed.

*Docker File Examples*

Here are some examples of Docker files that can be used for different purposes.

Below is a basic docker file example.

```dockerfile
FROM ubuntu
RUN apt-get update && apt-get install -y nginx
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

This is a basic example of a Docker file, which will install the nginx web server and expose port 80.

Now, here is another exampe of a docker file that is multi-stage. 
```dockerfile
FROM ubuntu as builder
RUN apt-get update && apt-get install -y nginx

FROM ubuntu
COPY --from=builder /usr/bin/nginx /usr/bin/nginx
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

This is a multi-stage Docker file:
- In stage 1, it builds the nginx web server
- in stage 2, it deploys it

Also, we could use a docker compose file in a yaml format to build an image. 
```yaml
version: '3'
services:
  web:
    build: .
    ports:
      - "80:80"
    volumes:
      - .:/code
    command: nginx -g 'daemon off;'
```

This is a Docker Compose file, which will build the nginx web server, expose port 80, and mount the current working directory as 
a volume.

*Last Words*
Docker files can be a valuable asset to developers, as they provide a quick, straightforward way to create and deploy applications 
to any system. Plus, they are portable, meaning they can be used on any operating system. With the many examples available, developers 
can set up and launch applications in no time.

*How do I run a Docker File?*
To run a Docker File, use the command:
```shell
docker build -t <image name> .’ 
``` 
This should be run in the directory where the Docker File is located.

*What are the common commands used in Docker File?*
Common commands used in Docker Files include `RUN`, `ENV`, `EXPOSE`, `ADD`, `COPY`, `WORKDIR`, `CMD`, and `ENTRYPOINT`.

*What are the different stages of a Docker File?*
The different stages of a Docker File include writing the Docker File, building the image, running the image, and pushing 
the image to a registry.

*How do I manage dependencies in a Docker File?*
Dependencies can be managed in a Docker File by using the RUN command to install them and the COPY command to copy them 
into the image.

*What is the best way to store and share a Docker File?*
The best way to store and share a Docker File is to use a version control system such as Git and push it to a repository.

*How do I debug a Docker File?*
To debug a Docker File, use the command:
```shell
docker build --rm -t <image name> .
```
It is used to build the image and display the output of the different commands of the Docker File in the terminal.

*What are the security considerations when using Docker Files?*
Security considerations when using Docker Files include ensuring that the image is secure, using secure credentials, 
and avoiding the use of privileged instructions.

**How to Convert a Byte of Slices []byte to an io.Reader?**


*Problem*
This question arose when I was checking a code example that shows how to test an API in the Gin framework.

Here is the code snippet:

```go
jsonValue, _ := json.Marshal(profile)
req, _ := http.NewRequest("POST", "/profile", bytes.NewBuffer(jsonValue))
```

The `jsonValue` type is of type `[]byte` and I wondered why we needed to pass it to `bytes.NewBuffer` instead 
of just passing the byte slice to the `NewRequest` function.

*Answer*

The answer is to be found in the definition of the `http.NewRequest` in which the third argument expects an 
`io.Reader` type which is an interface that represents an input stream. 

The `bytes.NewBuffer` function returns an `io.Reader` type, thus it is used to convert the `[]byte` to an 
`io.Reader`.

The signature of the `http.NewRequest` function is:

```go
func NewRequest(method, url string, body io.Reader) (*Request, error)
```

The `bytes.NewBuffer` returns an `io.Reader` type, or a type that implements the interface:
```go
type Reader interface {
        Read(p []byte) (n int, err error)
}
```

The above interface represents an input stream.

The signature of the `bytes.NewBuffer` function is:

```go
func NewBuffer(buf []byte) *Buffer
```

And the `Buffer` implements the `io.Reader` interface.


*What is the most straightforward way to convert a byte slice to an io.Reader in Golang?*
The most straightforward way to convert a byte slice to an io.Reader in Golang is to use the 
bytes.NewReader function from the bytes package.

*What type of value does bytes.NewReader return?*
bytes.NewReader returns a value of type bytes.Reader which implements the io.Reader (and io.ReadSeeker) 
interface.

*What does io.Reader represent?*
io.Reader represents a type that can read data from a stream of bytes.

*Is io.Reader an interface?*
Yes, io.Reader is an interface which can be implemented by many different types.

*Is there any additional reading material recommended to learn more about interfaces in Go?*
Yes, Effective Go: Interfaces and Types is a great resource to learn more about interfaces in Go.



**Short Intro to Golang Generics**

This article is not comprehensive, as it only provides a basic introduction to Google Generics. I am using it 
as a reference for my own knowledge, and will update it as soon as the opportunity arises.


*What are Golang Generics?*

Golang generics allow you to write code that works with multiple types of data, without having to rewrite the code 
for each type. 

This lets you create functions and types that can work with different data types. In order to proceed, you use type 
parameters as placeholders for the types that the function will accept as arguments. 

Also, you can also create generic types, which let you store different types of data in the same data structure. 

Overall, generics provides you with the flexibility needed to make your code highly reusable. 


*Golang Generic Functions*

A generic function is written with type parameters. These type parameters act as placeholders for the types that the 
function will accept as arguments. The type parameters are then constrained with a type constraint, which specifies 
what types the function will accept as arguments. The type constraint also ensures that the argument types are 
permissible for the operations performed by the function.

Here is an example of a generic function below that can work with either `int64` or `float64` types. 

```go
// Sum sums the values of map m. It supports both int64 and float64
// as types for map values.
func Sum[K comparable, V int64 | float64](m map[K]V) V {
	var s V
	for _, v := range m {
		s += v
	}
	return s
}
```

**How to Use Environment Variables with Golang Package godotenv**

In today's article, I will share with you how to use environment variables with Golang using the `godotenv` package.

*Why Environment Variables are Needed?*
Environment variables are used to store configuration settings for an application in a secure and convenient manner. 
Environment variables are stored in the system, which helps keep the data secure from unauthorized access.
Finally, they make it possible to change an application's configuration without having to modify or touch the 
source code or having to use configuration files (json, yaml etc...). 

*Environment Variables Help with Code Management*
When using environment variables, code management becomes much easier, it is due to the fact that any changes to the 
environment variables can be applied to the entire application, rather than needing to be individually changed in all 
of the code files.
It also helps with avoid missing changes which happens when there are several code files that need to be edited in 
order to modify the configuration in the source code. 

*Benefits of Environment Variables over JSON Configuration Files*

There are advantages of using environment variables over json configuration files: 
- Environment variables are secure as they are stored in the system. 
- Environment variables are easier to manage, as any changes to the environment variables can be applied to the 
entire application. 
- Environment variables are more flexible than json files for configuration, as they can be used to store multiple 
variables and their values in a single place.

*Using godotenv Package*

I will introduce you the best package, in my humble opinion, to manage and load environment variables as of today Feb 2023. 

Of course, there is no need to introduce the `os` package and its function `os.Getenv` as the official documentation is
already doing a great job. Basically, you can access any loaded/available environment variable using its key passed
as an argument to the function `os.Getenv`.

The `godotenv` package is a great way to quickly and easily load environment variables from a `.env` file stored in the 
project root directory. 

First, you will need to install the `godotenv` in the projet root directory, using the command:
```shell
go get -u github.com/joho/godotenv
```

Now, we can create a new `.env` file, then use the `godotenv.Load()` function to read the file.

For instance, let's create a `.env` file with the variable HOST_NAME assigned to the value "localhost":

```text
HOST_NAME=localhost
```

Now, in order to access the value of this environment variable, we can use the `godotenv.Load()` function. 

First, in the `main.go` file, we need to import the package in question.

```go
import (
  "github.com/joho/godotenv"
  
  "os"
)
```

Next, we can create a function that will use the `godotenv.Load()` function to read our `.env` file and return the 
value of the specified key:

```go
func goDotEnvVariable(key string) string {
  err := godotenv.Load(".env")

  if err != nil {
    log.Fatalf("Error loading .env file")
  }
 
  // In order to get access a environment variable, we need to use the os package
  // Getenv(Key) will return the value of any available and loaded environment
  // variable based on its Key
  val := os.Getenv(key)

  return val
}
```

It is now possible to call this function from our `main()` function to access the value `HOST_NAME` variable.


```go

func main() {
  val := goDotEnvVariable("HOST_NAME")

  fmt.Printf("Example of usage of godotenv : %s = %s \n", "HOST_NAME", val)
}
```

Here is the output of the above program. 

```text
godotenv : STRONGEST_AVENGER = Thor
```

*Last Words*

The `godotenv` package is a great tool for quickly and easily loading and accessing environment variables stored 
in a `.env` file. 

















**What are Golang Mutable and Immutable Types?**


Immutable data types are an essential concept in computer science. Immutable data types are data types that cannot be altered or changed once they are declared. In fact, if you try to alter an immutable data type, it will create a copy of the original data and create a new version of the data. This is why immutable data types are important in programming – they ensure that data is not corrupted or changed unexpectedly.

In the programming language Go, there are several immutable data types available. These include Boolean, Integer, Float, Pointers, Strings and Interfaces. Let’s take a look at each of these types and how they work.


*What are Immutable Types?*

Immutable types in golang are those data types whose values can't be changed once they are declared. Values of these data types cannot be modified directly, instead a new memory address is allocated and the value is changed at that location. These types are also referred to as constant types and are useful for ensuring data integrity and security.

*Boolean is Immutable*

The Boolean data type is a simple one - it is either true or false. In Go, this is represented by the type bool. Boolean values are used to represent logical conditions, such as whether a statement is true or false. Here’s an example of a Boolean statement in Go:

```go
x := true

if x {
    fmt.Println("x is true!")
}
```

The above code will print out “x is true!” if the variable x is true.

Integer

The Integer data type is used to represent whole numbers. This includes both negative and positive numbers, as well as zero. In Go, integers are represented using the type int. Here’s an example of an integer in Go:

```go
x := 5

fmt.Println(x)
```

The above code will print out the number 5.

Float

The Float data type is used to represent numbers with decimal points. This includes both negative and positive numbers, as well as zero. Floats can also have an exponent, which is represented by an e in Go. Here’s an example of a float in Go:

```go
x := 5.3

fmt.Println(x)
```

The above code will print out the number 5.3.

*Pointers are Immutable*

Pointers are data types that store the address of another variable in memory. In Go, pointers are represented using the type *T. Here’s an example of a pointer in Go:

```go
x := 5

ptr := &x
```

fmt.Println(*ptr)

The above code will print out the number 5, which is the address stored in the pointer.

*String is Immutable*

The String data type is used to represent text. Strings are represented using the type string in Go. Here’s an example of a string in Go:

```go
x := "Hello world!"

fmt.Println(x)
```

The above code will print out the string “Hello world!”.

*Interfaces are Immutable*

Interfaces are data types that represent a set of methods that an object must implement. In Go, interfaces are represented using the type interface{}. Here’s an example of an interface in Go:

```go
type TestInterface interface {
    TestMethod()
}
```

The above code declares an interface called TestInterface. Any type that implements the TestMethod() method will be able to be used as a TestInterface.


*Now, What are Mutable Types?*

Mutable types in Golang are data types that can be modified without reallocating memory. They are essential for programs to be able to make changes to data without having to create new variables for each change. Mutable types in Golang include slices, maps, and channels, among others. With these mutable types, Golang provides a powerful and reliable way to manage data in programs.

*Slice is Mutable*

A slice is a dynamic data structure in Golang that is used to represent a list or array of values. It is similar to an array, but is more flexible as it can be dynamically modified by adding or removing elements from the list. A slice is created by specifying the size of the list and the data type of the elements. The following example creates a slice of integers of size 5:

```go
mySlice := make([]int, 5)
```

Once a slice is created, elements can be added and removed from it. To add elements to a slice, the append() function is used. The following example adds an element to the slice we created above:

```go
mySlice = append(mySlice, 6)
```

To remove elements from a slice, the slicing operator is used. The following example removes the last element from the slice we created above:

```go
mySlice = mySlice[:len(mySlice)-1]
```

*Array is Mutable*

An array is a fixed-length data structure in Golang that is used to store a sequence of elements. It is similar to a slice, but is more efficient as it has a fixed length which cannot be modified. An array is created by specifying the size of the array and the data type of the elements. The following example creates an array of integers of size 5:

```go
myArray := [5]int{}
```

Once an array is created, elements can be added and removed from it. To add elements to an array, the append() function is used. The following example adds an element to the array we created above:

myArray = append(myArray, 6)

To remove elements from an array, the slicing operator is used. The following example removes the last element from the array we created above:

```go
myArray = myArray[:len(myArray)-1]
```

*Map is Mutable*

A map is a key-value data structure in Golang that is used to store data in an unordered fashion. It is similar to a dictionary in other programming languages and is used to store data associated with a specific key. A map is created by specifying the data type of the key and the data type of the value. The following example creates a map of strings to integers:

```go
myMap := make(map[string]int)
```

Once a map is created, elements can be added and removed from it. To add elements to a map, the set() function is used. The following example adds an element to the map we created above:

```go
myMap["key"] = 6
```

To remove elements from a map, the delete() function is used. The following example removes the element with the specified key from the map we created above:

delete(myMap, "key")

*Channels are Mutable*

A channel is a data structure in Golang that is used to communicate between goroutines. It is used to send and receive values from one goroutine to another. A channel is created by specifying the data type of the element that will be sent and the capacity of the channel. The following example creates a channel of integers with a capacity of 5:

```go
myChannel := make(chan int, 5)
```

Once a channel is created, elements can be sent and received from it. To send a value to a channel, the send() function is used. The following example sends an element to the channel we created above:

```go
myChannel <- 6
```

To receive a value from a channel, the receive() function is used. The following example receives an element from the channel we created above:

```go
value := <-myChannel
```


**Rust CVEs Review**


*Main papers about it*

*Rust Out-of-bounds*

*Rust Use After Free*

*Rust Double Free*

*Rust Bufferoverflow*

*Rust Stackoverflow*


*How to Mitigate These Errors*

*Github Repository*


https://www.askpython.com/python/examples/in-and-not-in-operators-in-python

https://www.askpython.com/python/array/python-add-elements-to-an-array

```competitors
https://golang.ch
https://golangdocs.com/
https://www.linuxfordevices.com/

https://www.sohamkamani.com/archive/ 201k visitors and 172 articles
```


**What are your options for software development?**
https://dev.co/in-house-vs-outsourcing
The development industry has experienced a marked democratization in the last decade, leading to the emergence of a multitude of independent companies, agencies, and freelancers providing a vast array of services. These developers can be classified into four distinct categories: offshore, nearshore, onshore, and in-house. Offshore developers are situated in countries with different time zones and offer reduced costs but diminished responsiveness. Nearshore developers typically come from countries within similar time zones, allowing for improved communication and coordination. Onshore developers are located within the same country, thus eliminating language and cultural barriers. Lastly, in-house developers are employed on a full-time basis, working in direct conjunction with the organization. When seeking dependable, high-quality work, the last two options are often the most practical.

To rewrite
These Are Your Options for Development

Exploring the Pros and Cons of In-House Development
Exploring the Pros and Cons of Onshore Outsourcing

Dev.co: Your Source for Custom Software, Mobile, and Website Development


competitor:
https://www.techopedia.com/definition/21028/non-deterministic-polynomial-time-np
